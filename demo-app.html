<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mere Saamne Wali Khidhki</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@500;600&display=swap" rel="stylesheet">

<style>
    /* Fixed brand bar */
#brandBar{
  position: fixed;
  top: 0;
  left: 0;
  right: 0;

  height: 56px;
  display: flex;
  align-items: center;
  justify-content: center;

  background: rgba(255, 255, 255, 0.92);
  backdrop-filter: blur(8px);
  border-bottom: 1px solid rgba(235, 50, 70, 0.18);

  z-index: 10000;
}

#brandBar span{
    font-family: 'Cormorant Garamond', serif;
    font-weight: 1000;
    letter-spacing: 0.6px;
}

  :root{
  --bg-main: #ffffff;
  --bg-surface: rgba(255,255,255,0.86);

  --red1: rgba(235, 50, 70, 0.22);
  --red2: rgba(255, 120, 130, 0.16);
  --softBlack: rgba(0, 0, 0, 0.10);

  --accent-primary: #E57373;
  --accent-success: #22C55E;
  --accent-error: #EF4444;

  --text-main: #1A1A1F;
  --border-soft: rgba(235, 50, 70, 0.18);
}

body {
    margin: 0;
    padding: 80px 0 40px 0;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    min-height: 100vh;

    font-family: 'Inter', system-ui, -apple-system, sans-serif;
    background:
      radial-gradient(900px 520px at 20% 0%, var(--red1), transparent 60%),
      radial-gradient(900px 520px at 85% 10%, var(--softBlack), transparent 62%),
      radial-gradient(780px 480px at 50% 80%, var(--red2), transparent 60%),
      radial-gradient(520px 320px at 35% 55%, rgba(235, 50, 70, 0.10), transparent 60%),
      var(--bg-main);

    color: var(--text-main);
}

h1 {
    font-size: clamp(32px, 6vw, 60px);
    color: var(--text-main);
    text-align: center;
    margin-top: 12px;
    margin-bottom: 13px;
}

button {
    padding: clamp(8px, 2vw, 15px) clamp(14px, 4vw, 30px);
    font-size: clamp(14px, 2.2vw, 18px);

    background-color: var(--accent-primary);
    color: white;

    border: none;
    border-radius: 10px;
    cursor: pointer;

    transition: background-color 0.2s, transform 0.15s;
}

button:hover:not(:disabled) {
    background-color: #EF5350;
    transform: translateY(-1px);
}

button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

.button-group {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 20px;
    justify-content: center;
}

#stopButton {
    background-color: var(--accent-error);
}

#stopButton:hover:not(:disabled) {
    background-color: #DC2626;
}

#feedback {
    opacity: 0;
    transform: scale(0.96);
    transition:
        opacity 0.25s ease,
        transform 0.25s ease,
        background-color 0.25s ease;

    border-radius: 14px;
    padding: 12px 18px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.12);

    max-width: 520px;
    width: fit-content;
    margin: 6px auto 0 auto;
    text-align: center;
}

#feedback.show {
    opacity: 1;
    transform: scale(1);
}

#feedback.correct {
    background-color: var(--accent-success);
    color: white;
}

#feedback.wrong {
    background-color: var(--accent-error);
    color: white;
}

.note-feedback {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 6px;
    flex-wrap: wrap;
}

.note-circle {
    width: 42px;
    height: 42px;
    border-radius: 50%;

    background: #e5e7eb;
    color: #111;

    font-weight: 700;
    font-size: 14px;

    display: flex;
    align-items: center;
    justify-content: center;

    box-shadow: 0 3px 10px rgba(0,0,0,0.15);
}

.note-circle.correct {
    background: #E57373;
    color: white;
}

.note-circle.wrong {
    background: #EF4444;
    color: white;
}

.note-label {
    font-size: 14px;
    font-weight: 600;
    opacity: 0.9;
}

.note-explanation {
    font-size: 14px;
    margin-top: 6px;
    line-height: 1.4;
    opacity: 0.95;
}

#feedback .note-circle {
    color: inherit;
}

#holdInfo {
    font-size: 18px;
    font-weight: 600;
    text-align: center;
}

#notesDisplay {
    display: none !important;
}

#notesDisplay h2 { margin-top: 0; color: #333; font-size: 24px; }
.note-list { display: flex; flex-wrap: wrap; gap: 10px; }
.note-number { padding: 8px 12px; background-color: #e3f2fd; border-radius: 4px; font-size: 16px; color: #1976d2; }

#countdownOverlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 160px;
    font-weight: bold;
    color: #333;
    background: rgba(255, 255, 255, 0.9);
    padding: 40px 80px;
    border-radius: 20px;
    z-index: 9999;
    display: none;
    pointer-events: none;
}

#notesDisplay,
#notesList {
    font-size: 14px;
}

#midiDisplay h3 {
    font-size: 16px;
    margin: 6px 0 4px 0;
}

#notesList {
    margin-top: 4px;
    line-height: 1.3;
}

#midiDisplay {
    margin-top: 4px;
    font-size: 18px;
}

#midiDisplay > div:not(:empty) {
    margin-top: 6px;
}

.music-symbol {
    font-family: "Arial Unicode MS", "Segoe UI Symbol", "Noto Music", serif;
}

#sideNoteFeedback {
    position: fixed;
    right: 20px;
    top: 50%;
    transform: translateY(-90%);

    display: flex;
    flex-direction: column;
    gap: 14px;

    z-index: 1000;
}

#freeModeButton.side-floating {
    position: fixed;
    right: 20px;
    top: calc(50% - 260px);

    width: 64px;
    height: 64px;
    padding: 0;

    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;

    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;

    z-index: 1001;
}

.side-note {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
}

@media (max-width: 900px) {
    .button-group {
        flex-direction: column;
        align-items: stretch;
    }

    #practiceControls {
        flex-direction: column;
        align-items: stretch;
    }

    canvas {
        width: 100%;
        height: auto;
    }

    #holdInfo:empty {
        display: none;
    }
}

canvas {
    display: block;
}

#trainingProgress {
    position: relative;
    width: min(600px, 90%);
    height: 16px;
    background: #E5E7EB;
    border-radius: 999px;
    margin: 12px auto 0 auto;
    overflow: hidden;
}

#trainingProgressFill {
    height: 100%;
    width: 0%;
    background: linear-gradient(
        90deg,
        var(--accent-primary),
        var(--accent-success)
    );
    transition: width 0.3s ease;
}

#trainingProgressText {
    position: absolute;
    top: -24px;
    right: 0;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-main);
}

#bottomDock {
    margin-top: auto;
    padding-top: 100px;
    padding-bottom: 80px;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.falling-note {
    border-radius: 10px;
    filter: drop-shadow(0 4px 10px rgba(0,0,0,0.15));
}

/* ‚úÖ CRITICAL: Make app visible by default */
#app { 
    display: block; 
}
</style>
</head>
<body>
    <div id="brandBar">
        <span>Ria Om Shandilya</span>
    </div>      
    <h1>Mere Saamne Wali Khidhki</h1>

<div id="app">
    <!-- Training Progress Bar -->
    <div id="trainingProgress" style="display:none;">
        <div id="trainingProgressFill"></div>
        <span id="trainingProgressText">0%</span>
    </div>

    <div id="bottomDock">
        <div id="feedback"></div>
        <div id="holdInfo" style="color:#333;"></div>

        <canvas id="canvas" width="1400"></canvas>

        <div id="countdownOverlay">3</div>

        <!-- Right-side note indicators -->
        <div id="sideNoteFeedback">
            <div class="side-note">
                <div class="note-label">You pressed</div>
                <div id="pressedNoteCircle" class="note-circle"></div>
            </div>

            <div class="side-note">
                <div class="note-label">Correct note</div>
                <div id="correctNoteCircle" class="note-circle correct"></div>
            </div>
        </div>

        <div class="button-group" id="playbackControls">
            <div id="practiceControls" style="display:flex;gap:10px;align-items:center;">
                <label>
                    Hand:
                    <select id="handSelect">
                        <option value="treble">Right Hand (Treble)</option>
                        <option value="bass">Left Hand (Bass)</option>
                        <option value="both">Both Hands</option>
                    </select>
                </label>
            
                <label>
                    Start Measure:
                    <input id="startMeasureInput" type="number" min="1" value="1" style="width:60px;">
                </label>
                
                <label>
                    End Measure:
                    <input id="endMeasureInput" type="number" min="1" value="4" style="width:60px;">
                </label>
            
                <button id="startPracticeButton">Start Practice</button>
            </div>

            <button id="stopButton">Stop</button>
            <button id="freeModeButton">Free Mode</button>
            <button id="resetButton">Reset</button>
            <button id="toggleNamesButton">Hide Note Names</button>
            <button id="playSongButton">Play Full Song</button>
            <button id="beatToggle">Beat</button>
            <button id="countToggle">Counting</button>
            <button id="subdivisionToggle">1 & 2 &</button>
            <button id="languageToggle">EN</button>
            
            <label style="display:flex;align-items:center;gap:6px;font-size:16px;">
                <input type="checkbox" id="skipRepeatsCheckbox">
                Skip repeats in sheet
            </label>

            <label style="display:flex;align-items:center;gap:6px;font-size:16px;">
                <input type="checkbox" id="loopCheckbox">
                Loop section
            </label>

            <button id="speedDown">‚Äì</button>
            <span id="speedDisplay" style="font-size:18px;min-width:60px;text-align:center;">1.0√ó</span>
            <button id="speedUp">+</button>
        </div>

        <div id="notesDisplay" style="display: none;">
            <h2>Note Numbers:</h2>
            <div class="note-list" id="noteList"></div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"></script>
<script type="module">
import { Midi } from 'https://cdn.skypack.dev/@tonejs/midi@2.0.28';

// ===== TOUR: MIDI CONNECTION STATUS =====
let __tourMidiAccess = null;

function __tourSendMidiStatus() {
  const connected =
    !!__tourMidiAccess &&
    __tourMidiAccess.inputs &&
    __tourMidiAccess.inputs.size > 0;

  window.parent?.postMessage(
    { type: "tour:midi", connected },
    "*"
  );
}

// Try to detect MIDI on load (tells the tour even before any button is clicked)
if (navigator.requestMIDIAccess) {
  navigator.requestMIDIAccess()
    .then((ma) => {
      __tourMidiAccess = ma;
      __tourSendMidiStatus();

      ma.onstatechange = () => {
        __tourMidiAccess = ma;
        __tourSendMidiStatus();
      };
    })
    .catch(() => {});
}

// ================================
// SONG CONFIG (SHEET STRUCTURE)
// ================================
const SONG_CONFIG = {
    id: "demomeresaamne",
    title: "demomeresaamne",

    timeSignature: [4, 4],
    measures: 44,

    repeats: [],

    pickupBeats: 0
};

// ================================
// REPEAT MODEL (MIDI IS EXPANDED)
// ================================
const REPEAT_START = 0;
const REPEAT_END = 0;
const REPEAT_LEN = 0;

function buildPhysicalToLogicalMap(config) {
  const map = [];

  for (let p = 1; p <= config.measures; p++) {
    let logical;

    if (p <= 14) {
      logical = p;
    }
    else if (p <= 14 + REPEAT_LEN) {
      logical = REPEAT_START + (p - 15);
    }
    else {
      logical = p - REPEAT_LEN;
    }

    map[p] = logical;
  }

  return map;
}

const PHYSICAL_TO_LOGICAL = buildPhysicalToLogicalMap(SONG_CONFIG);

let MAX_LOGICAL_MEASURE = 0;
for (let p = 1; p <= SONG_CONFIG.measures; p++) {
  MAX_LOGICAL_MEASURE = Math.max(MAX_LOGICAL_MEASURE, PHYSICAL_TO_LOGICAL[p] || 0);
}

async function loadSongMidi() {
    const response = await fetch("demomeresaamne.mid");
    const arrayBuffer = await response.arrayBuffer();

    currentMidi = new Midi(arrayBuffer);

    allMidiNotes = [];

    currentMidi.tracks.forEach((track, trackIndex) => {
        const clef = trackIndex === 0 ? TREBLE : BASS;

        track.notes.forEach(note => {
            allMidiNotes.push({
                midi: note.midi,
                time: note.time,
                duration: note.duration,
                track: clef
            });
        });
    });

    allMidiNotes.sort((a, b) => a.time - b.time);
    allMidiNotes = splitRepeatedNotes(allMidiNotes);

    const bpm = currentMidi.header.tempos.length
        ? currentMidi.header.tempos[0].bpm
        : 120;

    secondsPerBeat = 60 / bpm;
    secondsPerMeasure = secondsPerBeat * SONG_CONFIG.timeSignature[0];
    
    MEASURE_TIME_MAP = buildMeasureTimeMap(SONG_CONFIG, secondsPerBeat);

    setControlsEnabled(true);
    showTrainingProgress();

    console.log("üéµ Song loaded", allMidiNotes.length, "notes");
}

// ==================================
// MEASURE ‚Üí TIME MAPPING
// ==================================
function buildMeasureTimeMap(config, secondsPerBeat) {
    const beatsPerMeasure = config.timeSignature[0];
    const secondsPerMeasure = beatsPerMeasure * secondsPerBeat;

    const map = {};

    for (let measure = 1; measure <= config.measures; measure++) {
        const startTime = (measure - 1) * secondsPerMeasure;
        const endTime = measure * secondsPerMeasure;

        map[measure] = {
            start: startTime,
            end: endTime
        };
    }

    return map;
}

// ================================
// TIME ‚Üí MEASURE LOOKUP
// ================================
function getMeasureFromTime(timeSeconds) {
    const EPS = 1e-6;
    const m = Math.floor((timeSeconds + EPS) / secondsPerMeasure) + 1;
    if (m < 1 || m > SONG_CONFIG.measures) return null;
    return m;
}

function getLogicalSheetMeasureFromTime(timeSeconds) {
  const physicalMeasure = getMeasureFromTime(timeSeconds);
  if (physicalMeasure === null) return null;
  return PHYSICAL_TO_LOGICAL[physicalMeasure] ?? null;
}

// ================================
// PRACTICE SEQUENCE BUILDER (PHYSICAL MEASURES)
// ================================

function logicalToPhysicalFirst(logical) {
  if (logical <= 14) return logical;
  return logical + REPEAT_LEN;
}

function logicalToPhysicalSecond(logical) {
  if (logical < REPEAT_START || logical > REPEAT_END) return null;
  return logical + 8;
}

function buildPhysicalPracticeMeasureSequence(startLogical, endLogical, skipRepeats) {
  if (startLogical > endLogical) return null;

  console.log("üîç Building sequence for logical", startLogical, "to", endLogical);
  console.log("   logicalToPhysicalFirst(21) =", logicalToPhysicalFirst(21));
  console.log("   logicalToPhysicalFirst(24) =", logicalToPhysicalFirst(24));
  console.log("   SONG_CONFIG.measures =", SONG_CONFIG.measures);

  const seq = [];
  const logicalSeq = [];

  if (skipRepeats) {
    for (let l = startLogical; l <= endLogical; l++) {
      const p = logicalToPhysicalFirst(l);
      if (!p || p > SONG_CONFIG.measures) return null;
      seq.push(p);
      logicalSeq.push(l);
    }
    return { seq, logicalSeq };
  }

  if (endLogical <= 26) {
    for (let l = startLogical; l <= endLogical; l++) {
      logicalSeq.push(l);
      seq.push(logicalToPhysicalFirst(l));
    }
  }
  else if (startLogical > 32) {
    for (let l = startLogical; l <= endLogical; l++) {
      logicalSeq.push(l);
      seq.push(logicalToPhysicalFirst(l));
    }
  }
  else {
    for (let l = startLogical; l <= Math.min(32, endLogical); l++) {
      logicalSeq.push(l);
      seq.push(logicalToPhysicalFirst(l));
    }
    
    for (let l = 27; l <= 32; l++) {
      logicalSeq.push(l);
      seq.push(logicalToPhysicalSecond(l));
    }

    if (endLogical > 32) {
      for (let l = 33; l <= endLogical; l++) {
        logicalSeq.push(l);
        seq.push(logicalToPhysicalFirst(l));
      }
    }
  }

  return { seq, logicalSeq };
}

// ================================
// CLEF DEFINITIONS (TRACK-BASED)
// ================================

const TREBLE = "treble";
const BASS = "bass";

const notesDisplay = document.getElementById('notesDisplay');
const noteList = document.getElementById('noteList');
const playbackControls = document.getElementById('playbackControls');
const handSelect = document.getElementById('handSelect');

function setControlsEnabled(enabled) {
    const controls = playbackControls.querySelectorAll(
        'button, select, input[type="number"], input[type="checkbox"]'
    );

    controls.forEach(el => {
        if (el.id === 'freeModeButton') return;
        el.disabled = !enabled;
    });
}

const startMeasureInput = document.getElementById('startMeasureInput');
const endMeasureInput = document.getElementById('endMeasureInput');
const startPracticeButton = document.getElementById('startPracticeButton');
const stopButton = document.getElementById('stopButton');
const toggleNamesButton = document.getElementById('toggleNamesButton');
const speedDownButton = document.getElementById('speedDown');
const speedUpButton = document.getElementById('speedUp');
const speedDisplay = document.getElementById('speedDisplay');
const resetButton = document.getElementById('resetButton');
const playSongButton = document.getElementById('playSongButton');
const loopCheckbox = document.getElementById('loopCheckbox');
const freeModeButton = document.getElementById('freeModeButton');

freeModeButton.classList.add('side-floating');
setControlsEnabled(true);

// Auto-load built-in song
(async () => {
    await loadSongMidi();
})();

function updateSpeed(delta) {
    if (visualsPlaying || previewMode || speedLocked) return;

    speedMultiplier = Math.min(
        2.0,
        Math.max(0.25, +(speedMultiplier + delta).toFixed(2))
    );

    speedDisplay.textContent = speedMultiplier.toFixed(2) + "√ó";

    if (metronomeRunning) {
        startMetronome();
    }
}

speedDownButton.addEventListener('click', () => updateSpeed(-0.25));
speedUpButton.addEventListener('click', () => updateSpeed(+0.25));

speedDownButton.disabled = false;
speedUpButton.disabled = false;

let showNoteNames = true;
let repeatEnabled = true;
let loopEnabled = false; 
let skipSheetRepeats = false;
let freeMode = false;

const skipRepeatsCheckbox = document.getElementById('skipRepeatsCheckbox');

// ================================
// METRONOME STATE (ISOLATED)
// ================================
let metroInterval = null;
let metroBeat = 0;
let metroSynth = null;
let beatEnabled = false;
let countEnabled = false;
let metronomeRunning = false;
let transportStartTime = null;
let countdownActive = false;

const speechSynth = window.speechSynthesis;

let countMode = "normal"; 
let subdivisionEnabled = false;
let countLanguage = "en";

function stopMetronome() {
    if (metroInterval) {
        cancelAnimationFrame(metroInterval);
        metroInterval = null;
    }

    metroBeat = 0;

    if (speechSynth) {
        speechSynth.cancel();
    }

    metronomeRunning = false;
}

const beatToggle = document.getElementById('beatToggle');
const countToggle = document.getElementById('countToggle');
const languageToggle = document.getElementById('languageToggle');
const subdivisionToggle = document.getElementById('subdivisionToggle');

languageToggle.addEventListener('click', () => {
    countLanguage = countLanguage === "en" ? "it" : "en";
    languageToggle.textContent = countLanguage.toUpperCase();
});

beatToggle.addEventListener('click', () => {
    beatEnabled = !beatEnabled;
    beatToggle.textContent = beatEnabled ? "Beat ‚úì" : "Beat";

    if (beatEnabled && !metronomeRunning) {
        startMetronome();
    }
});

countToggle.addEventListener('click', () => {
    if (!window.__chromeSpeechUnlocked) {
        const u = new SpeechSynthesisUtterance("one");
        u.volume = 1;
        u.rate = 1;
        speechSynthesis.speak(u);
        window.__chromeSpeechUnlocked = true;
    }

    countEnabled = !countEnabled;
    countToggle.textContent = countEnabled ? "Counting ‚úì" : "Counting";

    if (countEnabled && !metronomeRunning) {
        startMetronome();
    }
});

subdivisionToggle.addEventListener('click', () => {
    subdivisionEnabled = !subdivisionEnabled;

    countMode = subdivisionEnabled ? "subdivision" : "normal";

    subdivisionToggle.textContent =
        subdivisionEnabled ? "1 & 2 & ‚úì" : "1 & 2 &";

    if (subdivisionEnabled) {
        countEnabled = true;
        countToggle.textContent = "Counting ‚úì";
    }

    startMetronome(transportStartTime);
});

skipRepeatsCheckbox.addEventListener('change', () => {
    skipSheetRepeats = skipRepeatsCheckbox.checked;
});

toggleNamesButton.addEventListener('click', () => {
    showNoteNames = !showNoteNames;
    toggleNamesButton.textContent = showNoteNames
        ? 'Hide Note Names'
        : 'Show Note Names';
});

loopCheckbox.addEventListener('change', () => {
    loopEnabled = loopCheckbox.checked;
});

freeModeButton.addEventListener('click', async () => {
    await Tone.start();
    
    if (midiInputs.length === 0) {
        await initMIDI();
    }

    freeMode = !freeMode;

    freeModeButton.textContent =
        freeMode ? "Exit Free Mode" : "Free Mode";

    stopPlayback();

    trainingActive = false;
    previewMode = false;
    visualsPlaying = false;
    waitingForInput = false;

    fallingRectangles = [];
    expectedMidiNote = null;
    currentTrainingNote = null;

    document.getElementById('feedback').textContent =
        freeMode ? "Free Play ‚Äî play any note üéπ" : "";
});

stopButton.addEventListener('click', () => {
    stopPlayback(true);
});

resetButton.addEventListener('click', () => {
    resetAll();
});

let currentMidi = null;
let synth = null;
let freeModeSynth = null;

function ensureSynth() {
    if (!synth) {
        synth = new Tone.Sampler({
            urls: {
                "A0": "A0.mp3",
                "C1": "C1.mp3",
                "D#1": "Ds1.mp3",
                "F#1": "Fs1.mp3",
                "A1": "A1.mp3",
                "C2": "C2.mp3",
                "D#2": "Ds2.mp3",
                "F#2": "Fs2.mp3",
                "A2": "A2.mp3",
                "C3": "C3.mp3",
                "D#3": "Ds3.mp3",
                "F#3": "Fs3.mp3",
                "A3": "A3.mp3",
                "C4": "C4.mp3",
                "D#4": "Ds4.mp3",
                "F#4": "Fs4.mp3",
                "A4": "A4.mp3",
                "C5": "C5.mp3",
                "D#5": "Ds5.mp3",
                "F#5": "Fs5.mp3",
                "A5": "A5.mp3",
                "C6": "C6.mp3",
                "D#6": "Ds6.mp3",
                "F#6": "Fs6.mp3",
                "A6": "A6.mp3",
                "C7": "C7.mp3",
                "D#7": "Ds7.mp3",
                "F#7": "Fs7.mp3",
                "A7": "A7.mp3",
                "C8": "C8.mp3"
            },
            release: 1,
            baseUrl: "https://tonejs.github.io/audio/salamander/"
        }).toDestination();
    }

    freeModeSynth = synth;
}

let secondsPerBeat = 0.5;
let MEASURE_TIME_MAP = {};

let playbackTimeouts = [];
let isPlaying = false;
let midiInputs = [];
let pressedNotes = [];
let targetNote = null;

function showTrainingProgress() {
    document.getElementById('trainingProgress').style.display = 'block';
    updateTrainingProgress();
}

function hideTrainingProgress() {
    document.getElementById('trainingProgress').style.display = 'none';
}

function updateTrainingProgress() {
    if (!practiceNotes || practiceNotes.length === 0) return;

    const percent = Math.min(
        100,
        Math.round((trainingIndex / practiceNotes.length) * 100)
    );

    document.getElementById('trainingProgressFill').style.width =
        percent + "%";

    document.getElementById('trainingProgressText').textContent =
        percent + "%";
}

let trainingActive = false;
let trainingIndex = 0;
let waitingForInput = false;
let previewMode = false;
let previewTimeouts = [];
let retryTimeout = null; 
let fullSongPlaying = false;

let currentTrainingNote = null;
let noteHoldStartTime = null;
let expectedHoldDuration = 0;
let activeMidiNote = null;
let expectedMidiNote = null;

let expectedMidiTreble = new Set();
let expectedMidiBass   = new Set();
let currentChordNotes = new Set();
let midiPressedNotes = new Set();
let chordNotesCompleted = new Set();
let freeModeActiveNote = null;
let mouseDown = false;
let freeModeReleaseTimer = null;
let lastMouseMidi = null;

function hardStopUserNote() {
    if (!synth) return;

    if (activeMidiNote !== null) {
        synth.triggerRelease(getNoteName(activeMidiNote));
    }

    synth.releaseAll();

    activeMidiNote = null;
    noteHoldStartTime = null;
}

let failureCount = 0;
let autoSlowed = false;
let showBlackKeyArrow = false;
let arrowTargetGroup = null;
let explanationLocked = false;

let clefMode = 'treble';
let sectionStartTime = 0;
let sectionEndTime = 0;
let secondsPerMeasure = 2;

// Canvas setup
const START_NOTE = 36;
const END_NOTE = 96;
const TOTAL_NOTES = END_NOTE - START_NOTE + 1;
const KEYBOARD_HEIGHT = 130;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    const maxWidth = Math.min(window.innerWidth - 20, 1400);
    canvas.width = maxWidth;

    const NOTE_AREA_HEIGHT = 260;
    canvas.height = NOTE_AREA_HEIGHT + KEYBOARD_HEIGHT;
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let fallingRectangles = [];
let midiFallingNotes = [];
let songStartTime = null;
let visualClockStart = null;
let allMidiNotes = [];
let practiceNotes = [];
let visualsPlaying = false;
let speedMultiplier = 1.0;
let speedLocked = false;

function getFallTimeMs() {
    return 2000 / speedMultiplier;
}

const BLACK_KEYS = [1, 3, 6, 8, 10];
const NOTE_GAP_PX = 4;
const NOTE_GAP_TIME = 0.02;

function isBlackMidi(midi) {
    return BLACK_KEYS.includes(midi % 12);
}

function countWhiteKeys(start, end) {
    let count = 0;
    for (let m = start; m <= end; m++) {
        if (!isBlackMidi(m)) count++;
    }
    return count;
}

const TOTAL_WHITE_KEYS = countWhiteKeys(START_NOTE, END_NOTE);

function getWhiteKeyWidth() {
    return canvas.width / TOTAL_WHITE_KEYS;
}

function xToMidi(x) {
    let whiteKeyIndex = Math.floor(x / getWhiteKeyWidth());
    let count = 0;

    for (let midi = START_NOTE; midi <= END_NOTE; midi++) {
        if (!isBlackMidi(midi)) {
            if (count === whiteKeyIndex) return midi;
            count++;
        }
    }
    return null;
}

function noteToX(midi) {
    let whiteIndex = 0;

    for (let m = START_NOTE; m < midi; m++) {
        if (!isBlackMidi(m)) {
            whiteIndex++;
        }
    }

    let x = whiteIndex * getWhiteKeyWidth();

    if (isBlackMidi(midi)) {
        x -= getWhiteKeyWidth() * 0.35;
    }

    return x;
}

// ================================
// RHYTHM ‚Üí MUSICAL NOTE NAME
// ================================
function beatsToNoteName(beats) {
    const values = [
        { beats: 4, name: "‚óã" },
        { beats: 3, name: "d." },
        { beats: 2, name: "d" },
        { beats: 1.5, name: "‚ô©." },
        { beats: 1, name: "‚ô©" },
        { beats: 0.75, name: "‚ô™." },
        { beats: 0.5, name: "‚ô™" },
        { beats: 0.25, name: "‚ô¨" }
    ];

    let closest = values[0];
    let smallestDiff = Math.abs(beats - values[0].beats);

    for (const v of values) {
        const diff = Math.abs(beats - v.beats);
        if (diff < smallestDiff) {
            smallestDiff = diff;
            closest = v;
        }
    }

    return closest.name;
}

function getNoteName(midiNote) {
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const note = noteNames[midiNote % 12];
    const octave = Math.floor(midiNote / 12) - 1;
    return note + octave;
}

function explainWrongNote(playedMidi, expectedMidi) {
    const playedName = getNoteName(playedMidi);
    const expectedName = getNoteName(expectedMidi);

    const playedPitch = playedMidi % 12;
    const expectedPitch = expectedMidi % 12;

    if (playedPitch === expectedPitch) {
        const octaveDiff = Math.round((playedMidi - expectedMidi) / 12);

        if (octaveDiff > 0) {
            return `You played the correct note (${playedName[0]}), but it should be ${Math.abs(octaveDiff)} octave lower.`;
        } else if (octaveDiff < 0) {
            return `You played the correct note (${playedName[0]}), but it should be ${Math.abs(octaveDiff)} octave higher.`;
        }
    }

    return `Almost There! Let's try again üòä`;
}

function drawKeyboard() {
    const keyHeight = KEYBOARD_HEIGHT;
    const keyboardTop = canvas.height - KEYBOARD_HEIGHT;

    // WHITE KEYS
    let whiteIndex = 0;

    for (let midi = START_NOTE; midi <= END_NOTE; midi++) {
        if (isBlackMidi(midi)) continue;

        const x = whiteIndex * getWhiteKeyWidth();
        const isTreble = expectedMidiTreble.has(midi);
        const isBass   = expectedMidiBass.has(midi);
        
        if (isTreble) {
            ctx.fillStyle = "#FFCDD2";
        } else if (isBass) {
            ctx.fillStyle = "#757575";
        } else {
            ctx.fillStyle = "#ffffff";
        }
        
        ctx.fillRect(x, keyboardTop, getWhiteKeyWidth(), keyHeight);

        ctx.strokeStyle = "#000";
        ctx.strokeRect(x, keyboardTop, getWhiteKeyWidth(), keyHeight);

        if (showNoteNames) {
            ctx.fillStyle = "#000";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";

            ctx.fillText(
                getNoteName(midi),
                x + getWhiteKeyWidth() / 2,
                keyboardTop + keyHeight - 5
            );
        }

        whiteIndex++;
    }

    // BLACK KEYS
    whiteIndex = 0;

    for (let midi = START_NOTE; midi <= END_NOTE; midi++) {
        if (!isBlackMidi(midi)) {
            whiteIndex++;
            continue;
        }

        const blackKeyWidth = getWhiteKeyWidth() * 0.6;
        const blackKeyHeight = keyHeight * 0.6;

        const x = (whiteIndex - 1) * getWhiteKeyWidth() + getWhiteKeyWidth() * 0.7;

        const isTreble = expectedMidiTreble.has(midi);
        const isBass   = expectedMidiBass.has(midi);

        if (isTreble) {
            ctx.fillStyle = "#E57373";
        } else if (isBass) {
            ctx.fillStyle = "#424242";
        } else {
            ctx.fillStyle = "#000";
        }

        ctx.fillRect(x, keyboardTop, blackKeyWidth, blackKeyHeight);

        if (showNoteNames) {
            ctx.fillStyle = "#fff";
            ctx.font = "10px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";

            ctx.fillText(
                getNoteName(midi),
                x + blackKeyWidth / 2,
                keyboardTop + blackKeyHeight - 4
            );
        }
    }
}

function describeNoteByBlackKeys(midiNote) {
    const noteInOctave = midiNote % 12;

    const descriptions = {
        0: "the white key just before a group of 2 black keys (C)",
        1: "the first black key in a group of 2 (C#)",
        2: "the white key between the 2 black keys (D)",
        3: "the second black key in a group of 2 (D#)",
        4: "the white key just after the group of 2 black keys (E)",
        5: "the white key just before a group of 3 black keys (F)",
        6: "the first black key in a group of 3 (F#)",
        7: "the white key between the first and second black keys (G)",
        8: "the second black key in a group of 3 (G#)",
        9: "the white key between the second and third black keys (A)",
        10:"the third black key in a group of 3 (A#)",
        11:"the white key just after the group of 3 black keys (B)"
    };

    return descriptions[noteInOctave] || "";
}

function blackKeyGroupForMidi(midi) {
    const pitch = midi % 12;

    if (pitch === 1 || pitch === 3) return "2";

    if (pitch === 6 || pitch === 8 || pitch === 10) return "3";

    return null;
}

// =======================================
// SHARED USER NOTE HANDLER (MIDI + MOUSE)
// =======================================
function processUserNoteOn(midiNote) {
    if (!freeMode) {
        hardStopUserNote();
    }

    if (previewMode) return;

    // FREE MODE ‚Äî LEGATO / GLIDE WITH AUTO-RELEASE
    if (freeMode) {
        ensureSynth();

        freeModeSynth.triggerAttack(getNoteName(midiNote));
        freeModeActiveNote = midiNote;
        
        expectedMidiTreble.clear();
        expectedMidiBass.clear();
        expectedMidiTreble.add(midiNote);

        canvas.addEventListener('mouseleave', () => {
            mouseDown = false;

            if (freeMode && freeModeActiveNote !== null) {
                freeModeSynth.triggerRelease(getNoteName(freeModeActiveNote));
                freeModeActiveNote = null;
                expectedMidiNote = null;
            }
        });

        document.getElementById('pressedNoteCircle').textContent = getNoteName(midiNote);
        document.getElementById('pressedNoteCircle').className = 'note-circle';
        document.getElementById('correctNoteCircle').textContent = '';

        expectedMidiNote = midiNote;
        return;
    }

    // TRAINING MODE ONLY
    if (!trainingActive) return;

    const noteName = getNoteName(midiNote);
    const feedback = document.getElementById('feedback');

    // ---------- WRONG NOTE ----------
    if (!currentChordNotes.has(midiNote)) {
        const expectedMidi = allMidiNotes[trainingIndex].midi;
        const explanation = explainWrongNote(midiNote, expectedMidi);

        feedback.textContent = explanation;
        feedback.classList.remove('correct', 'wrong', 'show');
        void feedback.offsetWidth;
        feedback.classList.add('wrong', 'show');

        failureCount++;
        expectedMidiNote = expectedMidi;
        
        document.getElementById('pressedNoteCircle').textContent = getNoteName(midiNote);
        document.getElementById('pressedNoteCircle').className = 'note-circle wrong';
        document.getElementById('correctNoteCircle').textContent = currentTrainingNote;
        return;
    }

    // ---------- CORRECT NOTE ----------
    document.getElementById('pressedNoteCircle').textContent = getNoteName(midiNote);
    document.getElementById('pressedNoteCircle').className = 'note-circle correct';
    document.getElementById('correctNoteCircle').textContent = currentTrainingNote;
    
    explanationLocked = false;
    showBlackKeyArrow = false;
    arrowTargetGroup = null;
    failureCount = 0;

    midiPressedNotes.add(midiNote);

    const allPressed = Array.from(currentChordNotes).every(midi => midiPressedNotes.has(midi));

    if (allPressed && noteHoldStartTime === null) {
        const isChord = currentChordNotes.size > 1;
        feedback.textContent = isChord ? 'Hold this chord' : 'Hold this note';
        noteHoldStartTime = performance.now();
    } else if (!allPressed) {
        const remaining = Array.from(currentChordNotes).filter(m => !midiPressedNotes.has(m));
        feedback.textContent = `Keep holding, add: ${remaining.map(m => getNoteName(m)).join(' + ')}`;
    }

    feedback.classList.remove('correct', 'wrong', 'show');
    void feedback.offsetWidth;
    feedback.classList.add('show');

    activeMidiNote = midiNote;
    ensureSynth();

    synth.triggerAttack(noteName);
}

function isBlackKey(noteName) { 
    return noteName.includes("#"); 
}

function addMidiFallingRectangle(midiNumber, duration, track, noteStartTime) {
    const x = noteToX(midiNumber);

    const height = Math.max(12, duration * 150 - NOTE_GAP_PX);
    const TOP_GAP = 10;
    const startY = -height - TOP_GAP;
    const endY = canvas.height - KEYBOARD_HEIGHT - height;

    const gradient = ctx.createLinearGradient(0, startY, 0, startY + height);

    if (track === TREBLE) {
        gradient.addColorStop(0.00, "#FFEBEE");
        gradient.addColorStop(0.25, "#EF9A9A");
        gradient.addColorStop(0.55, "#E57373");
        gradient.addColorStop(1.00, "#EF5350");
    }
    else if (track === BASS) {
        gradient.addColorStop(0.00, "#616161");
        gradient.addColorStop(0.25, "#424242");
        gradient.addColorStop(0.55, "#212121");
        gradient.addColorStop(1.00, "#000000");
    }

    fallingRectangles.push({
        midi: midiNumber,
        noteName: getNoteName(midiNumber),
        track,
        isMidi: true,

        x,
        y: startY,
        startY,
        endY,
        width: getWhiteKeyWidth() * 0.86,
        height,

        gradient,
        startTime: noteStartTime,
        landed: false,
    });
}

function spawnTrainingNote(noteObj) {
    hardStopUserNote();
    trainingActive = true;
    visualsPlaying = true;
    fallingRectangles = [];

    previewTimeouts.forEach(t => clearTimeout(t));
    previewTimeouts = [];

    const noteName = getNoteName(noteObj.midi);
    const beats = noteObj.duration / secondsPerBeat;
    const beatLabel = beatsToNoteName(beats);

    currentTrainingNote = noteName;
    autoSlowed = false;
    waitingForInput = true;
    failureCount = 0;

    expectedHoldDuration = (noteObj.duration * 1000) / speedMultiplier;

    currentChordNotes.clear();
    chordNotesCompleted.clear();
    midiPressedNotes.clear();
    
    currentChordNotes.add(noteObj.midi);
    
    for (let i = trainingIndex + 1; i < practiceNotes.length; i++) {
        const nextNote = practiceNotes[i];
        const currentPlayTime = noteObj.playTime ?? noteObj.time;
        const nextPlayTime = nextNote.playTime ?? nextNote.time;
        
        if (Math.abs(nextPlayTime - currentPlayTime) < 0.01 && nextNote.track === noteObj.track) {
            currentChordNotes.add(nextNote.midi);
        } else if (Math.abs(nextPlayTime - currentPlayTime) >= 0.01) {
            break;
        }
    }

    const isChord = currentChordNotes.size > 1;
    
    const holdEl = document.getElementById('holdInfo');
    if (isChord) {
        holdEl.innerHTML = `Play chord: ${Array.from(currentChordNotes).map(m => getNoteName(m)).join(' + ')} (Hold for <span class="music-symbol">${beatLabel}</span>)`;
    } else {
        holdEl.innerHTML = `Hold for <span class="music-symbol">${beatLabel}</span>`;
    }
    
    noteHoldStartTime = null;
    setTargetNote(noteName);
    
    currentChordNotes.forEach(midi => {
        addMidiFallingRectangle(
            midi,
            noteObj.duration,
            noteObj.track,
            performance.now()
        );
    });

    if (isChord) {
        expectedMidiTreble.clear();
        expectedMidiBass.clear();
        
        currentChordNotes.forEach(midi => {
            if (noteObj.track === TREBLE) {
                expectedMidiTreble.add(midi);
            } else if (noteObj.track === BASS) {
                expectedMidiBass.add(midi);
            }
        });
    }
}

function playMeasurePreview(startTime, clef) {
    speedLocked = true;
    ensureSynth();
    hardStopUserNote();

    trainingActive = false;
    visualsPlaying = true;
    fallingRectangles = [];
    previewMode = true;

    const feedback = document.getElementById('feedback');
    feedback.textContent = 'Listen first‚Ä¶';

    feedback.classList.remove('correct', 'wrong', 'show');
    void feedback.offsetWidth;
    feedback.classList.add('show');

    const sectionNotes = practiceNotes.filter(note => {
        const isTreble = note.track === TREBLE;
        const isBass   = note.track === BASS;

        return (
            clef === 'both' ||
            (clef === 'treble' && isTreble) ||
            (clef === 'bass' && isBass)
        );
    });

    const previewStart = performance.now();
    const visualPreroll = getFallTimeMs();

    visualClockStart = previewStart + visualPreroll;

    sectionNotes.forEach(note => {
        const t0 = (note.playTime ?? note.time);
        const visualStart = visualClockStart + (((t0 - startTime) * 1000) / speedMultiplier) - getFallTimeMs();

        addMidiFallingRectangle(
            note.midi,
            note.duration,
            note.track,
            visualStart
        );
        
        const t = setTimeout(() => {
            synth.triggerAttackRelease(
                getNoteName(note.midi),
                note.duration / speedMultiplier
            );
        }, visualPreroll + (((note.playTime ?? note.time) - startTime) * 1000) / speedMultiplier);

        previewTimeouts.push(t);
    });

    if (!sectionNotes.length) {
        speedLocked = false;
        previewMode = false;
        spawnNextValidNote();
        return;
    }

    const lastNoteEnd = Math.max(...sectionNotes.map(n => (n.playTime ?? n.time) + n.duration));

    const previewLength = ((lastNoteEnd - startTime) * 1000) / speedMultiplier;

    const endTimeout = setTimeout(() => {
        previewMode = false;
        speedLocked = false;

        const feedback = document.getElementById('feedback');
        feedback.textContent = 'Your turn';
        feedback.classList.remove('correct', 'wrong', 'show');

        spawnNextValidNote();
    }, visualPreroll + previewLength + 400);

    previewTimeouts.push(endTimeout);
}

function spawnNextValidNote(){
    while (trainingIndex < practiceNotes.length) {
        const note = practiceNotes[trainingIndex];
        const currentMeasure = getLogicalSheetMeasureFromTime(note.time);

        const isTreble = note.track === TREBLE;
        const isBass   = note.track === BASS;

        if (
            clefMode === 'both' ||
            (clefMode === 'treble' && isTreble) ||
            (clefMode === 'bass' && isBass)
        ) {
            spawnTrainingNote(note);
            return;
        }

        trainingIndex++;
        updateTrainingProgress();
    }

    if (loopEnabled) {
        trainingIndex = 0;
        document.getElementById('feedback').textContent = 'Looping section‚Ä¶';
        setTimeout(() => {
            playMeasurePreview(sectionStartTime, clefMode);
        }, 600);
        return;
    }

    const feedback = document.getElementById('feedback');
    feedback.textContent = 'Excellent work! üåü';

    feedback.classList.remove('wrong');
    feedback.classList.add('correct', 'show');

    trainingActive = false;
    stopButton.disabled = true;
window.parent?.postMessage({ type: "tour:resume" }, "*");
}

function startVisualCountdown(onComplete) {
    const overlay = document.getElementById('countdownOverlay');
    let count = 3;

    countdownActive = true;
    overlay.style.display = 'block';
    overlay.textContent = count;

    const tick = () => {
        count--;

        if (count > 0) {
            overlay.textContent = count;
            setTimeout(tick, 1000);
        } else {
            overlay.style.display = 'none';
            countdownActive = false;
            onComplete();
        }
    };

    setTimeout(tick, 1000);
}

// Animation loop
function animate() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const keyboardTop = canvas.height - KEYBOARD_HEIGHT;
    const now = performance.now();

    if (visualsPlaying) {
        fallingRectangles = fallingRectangles.filter(rect => {
            const elapsed = performance.now() - rect.startTime;
            const progress = elapsed / getFallTimeMs();

            rect.y = rect.startY + progress * (rect.endY - rect.startY);
            
            if (rect.isMidi && !rect.landed && rect.y >= rect.endY) {
                rect.landed = true;

                if (rect.track === TREBLE) {
                    expectedMidiTreble.add(rect.midi);
                } else if (rect.track === BASS) {
                    expectedMidiBass.add(rect.midi);
                }

                const isPartOfCurrentChord = currentChordNotes.has(rect.midi);
                
                if (!isPartOfCurrentChord) {
                    setTimeout(() => {
                        expectedMidiTreble.delete(rect.midi);
                        expectedMidiBass.delete(rect.midi);
                    }, 100);
                }
            }
            
            if (rect.y > canvas.height) {
                return false;
            }

            ctx.fillStyle = rect.gradient;

            const r = 9;
            ctx.beginPath();
            ctx.moveTo(rect.x + r, rect.y);
            ctx.lineTo(rect.x + rect.width - r, rect.y);
            ctx.quadraticCurveTo(rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + r);
            ctx.lineTo(rect.x + rect.width, rect.y + rect.height - r);
            ctx.quadraticCurveTo(rect.x + rect.width, rect.y + rect.height, rect.x + rect.width - r, rect.y + rect.height);
            ctx.lineTo(rect.x + r, rect.y + rect.height);
            ctx.quadraticCurveTo(rect.x, rect.y + rect.height, rect.x, rect.y + rect.height - r);
            ctx.lineTo(rect.x, rect.y + r);
            ctx.quadraticCurveTo(rect.x, rect.y, rect.x + r, rect.y);
            ctx.closePath();
            ctx.fill();

            ctx.save();
            ctx.globalCompositeOperation = "screen";
            ctx.globalAlpha = 0.22;

            const gloss = ctx.createLinearGradient(
                rect.x,
                rect.y,
                rect.x + rect.width,
                rect.y
            );

            gloss.addColorStop(0.0, "rgba(255,255,255,0.05)");
            gloss.addColorStop(0.4, "rgba(255,255,255,0.35)");
            gloss.addColorStop(0.6, "rgba(255,255,255,0.35)");
            gloss.addColorStop(1.0, "rgba(255,255,255,0.05)");

            ctx.fillStyle = gloss;
            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);

            ctx.restore();

            const shimmerSpeed = 0.0015 * speedMultiplier;
            const shimmerPhase = (performance.now() * shimmerSpeed) % 1;

            const shimmerY = rect.y + shimmerPhase * rect.height;

            const isDownbeat = metronomeRunning && (metroBeat % 4 === 0);

            ctx.save();
            ctx.globalAlpha = isDownbeat ? 0.28 : 0.18;
            ctx.globalCompositeOperation = "lighter";

            const shimmerGradient = ctx.createLinearGradient(
                0,
                shimmerY - 20,
                0,
                shimmerY + 20
            );

            shimmerGradient.addColorStop(0, "rgba(255,255,255,0)");
            shimmerGradient.addColorStop(0.5, "rgba(255,255,255,0.8)");
            shimmerGradient.addColorStop(1, "rgba(255,255,255,0)");

            ctx.fillStyle = shimmerGradient;
            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);

            ctx.restore();

            if (showNoteNames && rect.isMidi && rect.noteName) {
                if (rect.track === BASS) {
                    ctx.fillStyle = "rgba(255,255,255,0.95)";
                    ctx.shadowColor = "rgba(0,0,0,0.5)";
                } else {
                    ctx.fillStyle = "rgba(0,0,0,0.9)";
                    ctx.shadowColor = "rgba(255,255,255,0.7)";
                }
                
                ctx.font = "bold 15px Arial";
                ctx.shadowBlur = 2;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                ctx.fillText(
                    rect.noteName,
                    rect.x + rect.width / 2,
                    rect.y + rect.height / 2
                );
                ctx.shadowBlur = 0;
            }

            return true;
        });
    } 
    
    drawKeyboard();
    drawBlackKeyArrow();
    requestAnimationFrame(animate);
}

function drawBlackKeyArrow() {
    if (!showBlackKeyArrow || !arrowTargetGroup) return;

    const keyHeight = KEYBOARD_HEIGHT;
    const keyboardTop = canvas.height - KEYBOARD_HEIGHT;

    const targetMidi = arrowTargetGroup === "2" ? 61 : 66;

    const x = noteToX(targetMidi) + getWhiteKeyWidth() / 2;
    const y = keyboardTop - 140;

    ctx.strokeStyle = "red";
    ctx.lineWidth = 4;

    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, keyboardTop - 20);
    ctx.stroke();

    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.moveTo(x - 10, keyboardTop - 30);
    ctx.lineTo(x, keyboardTop - 20);
    ctx.lineTo(x + 10, keyboardTop - 30);
    ctx.fill();

    const text = `Group of ${arrowTargetGroup} black keys`;
    ctx.font = "16px Arial";
    const textWidth = ctx.measureText(text).width;

    const boxX = x - textWidth / 2 - 10;
    const boxY = y - 35;
    const boxWidth = textWidth + 20;
    const boxHeight = 28;

    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

    ctx.strokeStyle = "red";
    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

    ctx.fillStyle = "red";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, x, boxY + boxHeight / 2);
}

animate();

// ================================
// SIMPLE METRONOME (BUTTON ONLY)
// ================================
function getCountWord(beatIndex, subdivision = false) {
    const beat = (beatIndex % 4) + 1;

    const words = {
        en: {
            numbers: ["one", "two", "three", "four"],
            and: "and"
        },
        it: {
            numbers: ["uno", "due", "tre", "quattro"],
            and: "e"
        }
    };

    const lang = words[countLanguage] || words.en;

    if (countMode === "subdivision") {
        return subdivision ? lang.and : String(beat);
    }

    return lang.numbers[beat - 1];
}

function startMetronome(startTimeOverride = null) {
    stopMetronome();

    transportStartTime = startTimeOverride ?? performance.now();
    metronomeRunning = true;

    if (!metroSynth) {
        metroSynth = new Tone.NoiseSynth({
            noise: { type: "white" },
            envelope: { attack: 0.001, decay: 0.03, sustain: 0 },
            volume: -6
        }).toDestination();
    }

    const bpm = (60 / secondsPerBeat) * speedMultiplier;

    const stepMs = (60000 / bpm) / 2;

    let lastStep = -1;

    function tick() {
        if (!metronomeRunning) return;

        const elapsed = performance.now() - transportStartTime;
        const step = Math.floor(elapsed / stepMs);

        if (step !== lastStep) {
            lastStep = step;

            const isMainBeat = step % 2 === 0;
            const beatIndex = Math.floor(step / 2);

            if (beatEnabled && isMainBeat) {
                metroSynth.triggerAttackRelease("16n");
            }

            if (countEnabled && speechSynth) {
                let word = null;

                if (isMainBeat) {
                    word = getCountWord(beatIndex, false);
                } else if (subdivisionEnabled) {
                    word = getCountWord(beatIndex, true);
                }

                if (word) {
                    speechSynth.cancel();
                    const u = new SpeechSynthesisUtterance(word);
                    u.volume = isMainBeat ? 1 : 0.6;
                    u.rate = 1;
                    speechSynth.speak(u);
                }
            }
        }

        metroInterval = requestAnimationFrame(tick);
    }

    tick();
}

// ================================
// MOUSE INPUT (NOTE ON / OFF)
// ================================
function getMidiFromMouse(x, y) {
    const keyboardTop = canvas.height - KEYBOARD_HEIGHT;
    if (y < keyboardTop) return null;

    const whiteKeyWidth = getWhiteKeyWidth();
    const blackKeyWidth = whiteKeyWidth * 0.6;
    const blackKeyHeight = KEYBOARD_HEIGHT * 0.6;

    let whiteIndex = 0;

    for (let midi = START_NOTE; midi <= END_NOTE; midi++) {
        if (!isBlackMidi(midi)) {
            whiteIndex++;
            continue;
        }

        const bx = (whiteIndex - 1) * whiteKeyWidth + whiteKeyWidth * 0.7;

        if (
            x >= bx &&
            x <= bx + blackKeyWidth &&
            y >= keyboardTop &&
            y <= keyboardTop + blackKeyHeight
        ) {
            return midi;
        }
    }

    return xToMidi(x);
}

canvas.addEventListener('mousedown', async (e) => {
    if (previewMode) return;
    await Tone.start();

    mouseDown = true;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (y < canvas.height - KEYBOARD_HEIGHT) return;

    const midiNote = getMidiFromMouse(x, y);
    if (midiNote === null) return;

    lastMouseMidi = midiNote;

    processUserNoteOn(midiNote);
});

canvas.addEventListener('mousemove', (e) => {
    if (!mouseDown || !freeMode) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (y < canvas.height - KEYBOARD_HEIGHT) return;

    const midiNote = getMidiFromMouse(x, y);
    if (midiNote === null || midiNote === lastMouseMidi) return;

    lastMouseMidi = midiNote;
    processUserNoteOn(midiNote);
});

canvas.addEventListener('mouseup', () => {
    mouseDown = false;
    lastMouseMidi = null;

    if (freeMode && freeModeActiveNote !== null) {
        freeModeSynth.triggerRelease(getNoteName(freeModeActiveNote));
        freeModeActiveNote = null;
        expectedMidiNote = null;
        expectedMidiTreble.clear();
        return;
    }

    if (activeMidiNote === null || noteHoldStartTime === null) return;
    
    if (getNoteName(activeMidiNote) !== currentTrainingNote) {
        activeMidiNote = null;
        noteHoldStartTime = null;
        return;
    }

    const note = activeMidiNote;
    const heldTime = performance.now() - noteHoldStartTime;

    synth.triggerRelease(getNoteName(note));

    if (heldTime >= expectedHoldDuration) {
        const feedback = document.getElementById('feedback');
        feedback.textContent = 'Good!';

        feedback.classList.remove('correct', 'wrong', 'show');
        void feedback.offsetWidth;
        feedback.classList.add('correct', 'show');
        explanationLocked = false;
        
        waitingForInput = false;
        expectedMidiNote = null;
        
        expectedMidiTreble.clear();
        expectedMidiBass.clear();
        
        trainingIndex += currentChordNotes.size;
        updateTrainingProgress();

        document.getElementById('holdInfo').textContent = '';
        setTimeout(() => spawnNextValidNote(), 300);

    } else {
        const heldBeats = heldTime / 1000 / secondsPerBeat;
        const expectedBeats = expectedHoldDuration / 1000 / secondsPerBeat;

        const feedback = document.getElementById('feedback');
        feedback.innerHTML = `You held <span class="music-symbol">${beatsToNoteName(heldBeats)}</span>. Let's try holding a little longer!`;

        feedback.classList.remove('correct', 'wrong', 'show');
        void feedback.offsetWidth;
        feedback.classList.add('wrong', 'show');

        const holdEl = document.getElementById('holdInfo');
        holdEl.innerHTML = `Hold for <span class="music-symbol">${beatsToNoteName(expectedBeats)}</span>`;

        if (retryTimeout) {
            clearTimeout(retryTimeout);
        }

        retryTimeout = setTimeout(() => {
            spawnTrainingNote(practiceNotes[trainingIndex]);
        }, 600);
    }

    noteHoldStartTime = null;
    activeMidiNote = null;
});

// MIDI handling
async function initMIDI() {
  if (!navigator.requestMIDIAccess) {
    console.log("Web MIDI API not supported");
    return;
  }

  try {
    const midiAccess = await navigator.requestMIDIAccess();
    __tourMidiAccess = midiAccess;

    // Send initial status (if already connected)
    __tourSendMidiStatus();

    // Attach current inputs
    midiInputs = []; // reset so we don't duplicate
    for (const input of midiAccess.inputs.values()) {
      midiInputs.push(input);
      input.onmidimessage = handleMIDIMessage;
    }

    // Watch for plug/unplug events
    midiAccess.onstatechange = () => {
      midiInputs = [];
      for (const input of midiAccess.inputs.values()) {
        midiInputs.push(input);
        input.onmidimessage = handleMIDIMessage;
      }

      __tourSendMidiStatus();
    };
  } catch (err) {
    console.error(err);
  }
}

function setTargetNote(noteName){
    targetNote = noteName;
}

function splitRepeatedNotes(notes, gapSeconds = NOTE_GAP_TIME) {
    const result = [];

    for (let i = 0; i < notes.length; i++) {
        const current = notes[i];
        const prev = result[result.length - 1];

        if (
            prev &&
            prev.midi === current.midi &&
            prev.track === current.track &&
            Math.abs((prev.time + prev.duration) - current.time) < 0.001
        ) {
            prev.duration = Math.max(0, prev.duration - gapSeconds);

            result.push({
                ...current,
                time: current.time + gapSeconds
            });
        } else {
            result.push({ ...current });
        }
    }

    return result;
}

function removeRepeatedMeasures(notes, secondsPerMeasure) {
    const measures = new Map();
    const result = [];

    for (const note of notes) {
        const measureIndex = Math.floor(note.time / secondsPerMeasure);

        if (!measures.has(measureIndex)) {
            measures.set(measureIndex, []);
        }

        measures.get(measureIndex).push(note);
    }

    const seenSignatures = new Set();

    for (const [measureIndex, measureNotes] of measures.entries()) {
        const signature = JSON.stringify(
            measureNotes.map(n => [
                n.midi,
                +(n.time % secondsPerMeasure).toFixed(3),
                +n.duration.toFixed(3),
                n.track
            ])
        );

        if (seenSignatures.has(signature)) {
            continue;
        }

        seenSignatures.add(signature);
        result.push(...measureNotes);
    }

    return result.sort((a, b) => a.time - b.time);
}

function reportEmptyLogicalMeasures(startLogical, endLogical, notes) {
    const counts = new Map();
    for (let m = startLogical; m <= endLogical; m++) counts.set(m, 0);

    for (const n of notes) {
        const lm = (n.logicalMeasure ?? getLogicalSheetMeasureFromTime(n.time));
        if (lm !== null && lm >= startLogical && lm <= endLogical) {
            counts.set(lm, (counts.get(lm) || 0) + 1);
        }
    }

    const empty = [];
    for (let m = startLogical; m <= endLogical; m++) {
        if ((counts.get(m) || 0) === 0) empty.push(m);
    }

    console.log("Notes per logical bar:", Object.fromEntries(counts));
    if (empty.length) console.warn("Empty logical bars in this hand:", empty.join(", "));
    return empty;
}

startPracticeButton.addEventListener('click', async () => {
    await Tone.start();
    
    if (midiInputs.length === 0) {
        await initMIDI();
    }
    
    hardStopUserNote();

    const selectedHand = handSelect.value;
    const startMeasure = parseInt(startMeasureInput.value, 10);
    const endMeasure = parseInt(endMeasureInput.value, 10);

    if (
        isNaN(startMeasure) ||
        isNaN(endMeasure) ||
        startMeasure < 1 ||
        endMeasure < startMeasure
    ) {
        alert("Invalid measure range");
        return;
    }
    
    if (endMeasure > MAX_LOGICAL_MEASURE) {
        alert(`Max sheet measure is ${MAX_LOGICAL_MEASURE}`);
        return;
    }

    const startLogical = startMeasure;
    const endLogical   = endMeasure;

    const built = buildPhysicalPracticeMeasureSequence(startLogical, endLogical, skipSheetRepeats);
    if (!built) {
        alert("Could not map that sheet range to the MIDI timeline.");
        return;
    }

    const physicalSeq = built.seq;
    const allowedPhysical = new Set(physicalSeq);

    const physicalIndex = new Map();
    physicalSeq.forEach((p, idx) => physicalIndex.set(p, idx));

    const logicalSeq =
        skipSheetRepeats
            ? Array.from({ length: endLogical - startLogical + 1 }, (_, i) => startLogical + i)
            : physicalSeq.map(p => PHYSICAL_TO_LOGICAL[p]);

    console.log("Skip repeats:", skipSheetRepeats);
    console.log("Logical sequence:", logicalSeq.join(","));
    console.log("Physical measures used:", physicalSeq.join(","));

    sectionStartTime = 0;
    sectionEndTime   = physicalSeq.length * secondsPerMeasure;

    practiceNotes = allMidiNotes
        .map(note => {
            const p = getMeasureFromTime(note.time);
            if (p === null) return null;
            
            if (!allowedPhysical.has(p)) {
                if (note.time >= 48 && note.time <= 54) {
                    console.log("‚ùå REJECTED note at time", note.time.toFixed(2), "in physical measure", p, "- not in allowed set");
                }
                return null;
            }

            const measureStart = MEASURE_TIME_MAP[p]?.start ?? ((p - 1) * secondsPerMeasure);
            const measureEnd = MEASURE_TIME_MAP[p]?.end ?? (p * secondsPerMeasure);

            const TOLERANCE = 0.001;
            if (note.time < measureStart || note.time >= measureEnd + TOLERANCE) return null;

            const isTreble = note.track === TREBLE;
            const isBass   = note.track === BASS;
            if (selectedHand !== "both") {
                const want = selectedHand === "treble" ? isTreble : isBass;
                if (!want) return null;
            }

            const idx = physicalIndex.get(p);
            const offsetInMeasure = Math.max(0, note.time - MEASURE_TIME_MAP[p].start);

            const playTime = (idx * secondsPerMeasure) + offsetInMeasure;

            const logicalMeasure =
                skipSheetRepeats
                    ? (startLogical + idx)
                    : (PHYSICAL_TO_LOGICAL[p] ?? null);

            return {
                ...note,
                playTime,
                logicalMeasure,
                physicalMeasure: p,
            };
        })
        .filter(Boolean);

    practiceNotes.sort((a, b) => a.playTime - b.playTime);

    const emptyBars = reportEmptyLogicalMeasures(startMeasure, endMeasure, practiceNotes);

    if (emptyBars.length) {
        const feedback = document.getElementById('feedback');
        feedback.textContent =
            `FYI: no notes in bars ${emptyBars.join(", ")} for this hand.`;
        feedback.classList.remove('correct', 'wrong', 'show');
        void feedback.offsetWidth;
        feedback.classList.add('show');
    }

    if (practiceNotes.length === 0) {
        alert("No notes found for this selection");
        return;
    }

    trainingIndex = 0;
    showTrainingProgress();
    updateTrainingProgress();
    clefMode = selectedHand === 'both' ? 'both' : selectedHand;

    trainingActive = true;
    waitingForInput = false;

    stopButton.disabled = false;
    transportStartTime = performance.now();

    document.getElementById('feedback').textContent = 'Get ready‚Ä¶';

    startVisualCountdown(() => {
        transportStartTime = performance.now();

        if (beatEnabled || countEnabled) {
            startMetronome();
        }

        playMeasurePreview(sectionStartTime, clefMode);
    });
});

playSongButton.addEventListener('click', async () => {
    await Tone.start();

    fullSongPlaying = true;

    stopPlayback(false);
    ensureSynth();
    transportStartTime = performance.now();

    countEnabled = false;
    countToggle.textContent = "Counting";
    speechSynth.cancel();

    if ((beatEnabled || countEnabled) && !metronomeRunning) {
        startMetronome();
    }

    startFullSongPlayback();
});

function stopPlayback(userInitiated = false) {
    isPlaying = false;
    trainingActive = false;
    previewMode = false;
    visualsPlaying = false;
    waitingForInput = false;
    fullSongPlaying = false;
    speedLocked = false;

    stopMetronome();

    if (synth) synth.releaseAll();
    Tone.Transport.stop();
    Tone.Transport.cancel();

    playbackTimeouts.forEach(t => clearTimeout(t));
    playbackTimeouts = [];

    previewTimeouts.forEach(t => clearTimeout(t));
    previewTimeouts = [];

    fallingRectangles = [];
    expectedMidiNote = null;
    activeMidiNote = null;

    if (!userInitiated) return;

    hideTrainingProgress();

    const feedback = document.getElementById('feedback');
    feedback.textContent = 'Stopped';
    feedback.classList.remove('correct', 'wrong', 'show');
    void feedback.offsetWidth;
    feedback.classList.add('show');

    document.getElementById('countdownOverlay').style.display = 'none';
    stopButton.disabled = true;
}

function resetAll() {
    hideTrainingProgress();
    stopPlayback();

    trainingActive = false;
    fullSongPlaying = false;
    previewMode = false;
    waitingForInput = false;
    visualsPlaying = false;

    trainingIndex = 0;
    playbackTimeouts = [];
    previewTimeouts = [];
    fallingRectangles = [];

    expectedMidiNote = null;
    activeMidiNote = null;
    currentTrainingNote = null;
    noteHoldStartTime = null;
    pressedNotes = [];
    
    expectedMidiTreble.clear();
    expectedMidiBass.clear();
    currentChordNotes.clear();
    midiPressedNotes.clear();
    chordNotesCompleted.clear();

    const feedback = document.getElementById('feedback');
    feedback.textContent = '';

    feedback.classList.remove('correct', 'wrong', 'show');
    document.getElementById('holdInfo').textContent = '';

    speedMultiplier = 1.0;
    speedDisplay.textContent = '1.0√ó';

    beatEnabled = false;
    countEnabled = false;
    metronomeRunning = false;
    beatToggle.textContent = 'Beat';
    countToggle.textContent = 'Counting';
    subdivisionToggle.textContent = '1 & 2 &';
    stopMetronome();

    handSelect.value = 'treble';
    startMeasureInput.value = 1;
    endMeasureInput.value = 4;
    skipRepeatsCheckbox.checked = false;
    skipSheetRepeats = false;
    loopCheckbox.checked = false;

    feedback.textContent = 'All reset ‚Äî ready!';
    console.log('‚úÖ All reset');
    
    document.getElementById('pressedNoteCircle').textContent = '';
    document.getElementById('pressedNoteCircle').className = 'note-circle';
    document.getElementById('correctNoteCircle').textContent = '';

    stopButton.disabled = true;
}
    
function startFullSongPlayback() {
    const visualBaseline = performance.now() + 16;
    const now = performance.now();
    
    if (!allMidiNotes.length) return;
    songStartTime = performance.now();
    visualClockStart = songStartTime;
    
    if (beatEnabled || countEnabled) {
        startMetronome(songStartTime);
    }

    fullSongPlaying = true;
    visualsPlaying = true;

    fallingRectangles = [];
    playbackTimeouts = [];

    allMidiNotes.forEach(note => {
        const visualStartTime = visualBaseline + ((note.time * 1000) / speedMultiplier) - getFallTimeMs();

        addMidiFallingRectangle(
            note.midi,
            note.duration,
            note.track,
            visualStartTime
        );

        const t = setTimeout(() => {
            if (!fullSongPlaying) return;

            synth.triggerAttackRelease(
                getNoteName(note.midi),
                note.duration / speedMultiplier
            );
        }, (note.time * 1000) / speedMultiplier);

        playbackTimeouts.push(t);
    });

    const lastNote = allMidiNotes[allMidiNotes.length - 1];
    const endTime = ((lastNote.time + lastNote.duration) * 1000) / speedMultiplier;

    setTimeout(() => {
        if (fullSongPlaying) stopPlayback();
    }, endTime + 200);
    
    stopButton.disabled = false;
}

function handleMIDIMessage(event) {
    if (previewMode) return;
    
    Tone.start();
    
    const [status, note, velocity] = event.data;
    const messageType = status & 0xf0;

    const isNoteOn = messageType === 0x90 && velocity > 0;
    const isNoteOff = messageType === 0x80 || (messageType === 0x90 && velocity === 0);

    const noteName = getNoteName(note);
    const feedback = document.getElementById('feedback');

    if (isNoteOn) {
        pressedNotes = [noteName];
        processUserNoteOn(note);
    }
    
    if (isNoteOff) {
        if (freeMode && note === freeModeActiveNote) {
            freeModeSynth.triggerRelease(getNoteName(note));
            freeModeActiveNote = null;
            expectedMidiNote = null;
            expectedMidiTreble.clear();
            return;
        }

        if (!currentChordNotes.has(note)) return;
        
        midiPressedNotes.delete(note);
        
        synth.triggerRelease(getNoteName(note));
        
        if (midiPressedNotes.size > 0) return;
        
        if (noteHoldStartTime === null) return;

        const heldTime = performance.now() - noteHoldStartTime;

        if (heldTime >= expectedHoldDuration) {
            feedback.textContent = 'Good!';

            feedback.classList.remove('correct', 'wrong', 'show');
            void feedback.offsetWidth;
            feedback.classList.add('correct', 'show');
            explanationLocked = false;
            waitingForInput = false;
            expectedMidiNote = null;
            
            expectedMidiTreble.clear();
            expectedMidiBass.clear();
            
            trainingIndex += currentChordNotes.size;
            updateTrainingProgress();
            
            document.getElementById('holdInfo').textContent = '';

            setTimeout(() => spawnNextValidNote(), 300);
        } else {
            const heldBeats = heldTime / 1000 / secondsPerBeat;
            const expectedBeats = expectedHoldDuration / 1000 / secondsPerBeat;

            feedback.innerHTML = `Too short ‚Äî held <span class="music-symbol">${beatsToNoteName(heldBeats)}</span>, need <span class="music-symbol">${beatsToNoteName(expectedBeats)}</span>`;

            feedback.classList.remove('correct', 'wrong', 'show');
            void feedback.offsetWidth;
            feedback.classList.add('wrong', 'show');

            const holdEl = document.getElementById('holdInfo');
            holdEl.innerHTML = `Hold for <span class="music-symbol">${beatsToNoteName(expectedBeats)}</span>`;

            setTimeout(() => {
                spawnTrainingNote(practiceNotes[trainingIndex]);
            }, 600);
        }

        noteHoldStartTime = null;
        activeMidiNote = null;
    }
}
</script>

</body>
</html>

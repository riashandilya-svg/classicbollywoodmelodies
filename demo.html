<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Demo</title>

  <style>
    :root{
      --demo-bg: rgba(10,10,20,0.55);
      --demo-card: rgba(255,255,255,0.92);
      --demo-border: rgba(140,120,160,0.30);
      --demo-accent: #7E57C2;
      --demo-text: #111;
    }

    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#fff;
    }

    /* The real app */
    #appFrame{
      width: 100vw;
      height: 100vh;
      border: 0;
      display:block;
    }

    /* Overlay */
    #demoOverlay{
      position: fixed;
      inset: 0;
      background: var(--demo-bg);
      display:none;
      z-index: 999999;
      pointer-events: none;
    }

    /* Highlight rectangle */
    #demoHighlight{
      position: absolute;
      border: 3px solid var(--demo-accent);
      border-radius: 14px;
      box-shadow: 0 0 0 6px rgba(126,87,194,0.18), 0 18px 50px rgba(0,0,0,0.35);
      pointer-events: none;
      display:none;
      z-index: 1000000;
    }

    /* Tooltip card */
    #demoCard{
      position: fixed;
      width: min(420px, calc(100vw - 28px));
      background: var(--demo-card);
      border: 1px solid var(--demo-border);
      border-radius: 16px;
      padding: 14px;
      color: var(--demo-text);
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
      z-index: 1000001;
      display:none;
    }

    #demoTitle{
      font-weight: 800;
      font-size: 16px;
      margin: 0 0 6px 0;
    }

    #demoText{
      margin: 0 0 10px 0;
      line-height: 1.35;
      font-size: 14px;
    }

    #demoVideo{
      width: 100%;
      aspect-ratio: 16/9;
      border-radius: 12px;
      background: #000;
      display:none;
      margin: 8px 0 10px 0;
      overflow:hidden;
    }

    #demoVideo video{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
    }

    #demoControls{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content: space-between;
      margin-top: 8px;
    }

    .btn{
      border: 0;
      background: var(--demo-accent);
      color: #fff;
      border-radius: 10px;
      padding: 10px 12px;
      font-weight: 700;
      cursor: pointer;
      font-size: 14px;
    }

    .btn.secondary{
      background: #111;
    }

    .btn.ghost{
      background: transparent;
      color: #111;
      border: 1px solid rgba(0,0,0,0.18);
    }

    #demoStep{
      font-size: 13px;
      opacity: 0.8;
      font-weight: 600;
    }

    /* Small top bar for starting the tour */
    #demoTopBar{
      position: fixed;
      top: 14px;
      right: 14px;
      z-index: 1000002;
      display:flex;
      gap:10px;
      align-items:center;
    }
  </style>
</head>

<body>
  <!-- Your real app loads here -->
  <iframe id="appFrame" title="App"></iframe>

  <!-- Quick start button always visible -->
  <div id="demoTopBar">
    <button class="btn" id="startTourBtn">Start Demo</button>
    <button class="btn ghost" id="stopTourBtn" style="display:none;">Exit</button>
  </div>

  <!-- Overlay + highlight + card -->
  <div id="demoOverlay"></div>
  <div id="demoHighlight"></div>

  <div id="demoCard">
    <h3 id="demoTitle"></h3>
    <p id="demoText"></p>
    <div id="demoActionStatus" style="margin: 6px 0 10px 0; font-size: 13px; font-weight: 700;"></div>


    <div id="demoVideo">
      <video id="demoVideoEl" controls playsinline></video>
    </div>

    <div id="demoControls">
      <button class="btn ghost" id="backBtn">Back</button>
      <div id="demoStep"></div>
      <div style="display:flex; gap:10px;">
        <button class="btn secondary" id="skipBtn">Skip</button>
        <button class="btn" id="nextBtn">Next</button>
      </div>
    </div>
  </div>

<script>
  // STEP 1: SET YOUR REAL APP PAGE HERE
  const APP_URL = "https://riashandilya-svg.github.io/classicbollywoodmelodies/demo-app.html";

  // STEP 2: Define demo steps using CSS selectors that exist on the app page.
  // If a selector isn't found, the step will still show, but without highlight.
const STEPS = [
  {
    title: "Connect your keyboard (USB)",
    text: "1) Connect your piano/keyboard to your laptop using a USB cable (usually USB-B on the keyboard side).\n2) Watch this quick video: https://www.youtube.com/shorts/LgtWPJjceRw\n3) Come back and click Next.",
    selector: null,
    video: null
  },
{
  title: "Choose which hand to practice",
  text: "Use this dropdown to pick Right Hand, Left Hand, or Both. Try changing it once, then click Next when you're ready.",
  selector: "#handSelect",
  dim: false,
  video: null,
  action: {
    type: "change",
    selector: "#handSelect",
    prompt: "Try switching the hand option once.",
    doneText: "Done âœ… Hand selected."
  }
},
{
  title: "Pick your start measure",
  text: "Type the start measure from your sheet music here (for example: 1). Then click Next when you're ready.",
  selector: "#startMeasureInput",
  dim: false,
  video: null,
  action: {
    type: "input",
    selector: "#startMeasureInput",
    prompt: "Try typing a start measure (example: 1).",
    doneText: "Done âœ… Start measure set."
  }
},
{
  title: "Pick your end measure",
  text: "Now type the end measure from your sheet music (for example: 2). Then click Next when you're ready.",
  selector: "#endMeasureInput",
  dim: false,
  video: null,
  action: {
    type: "input",
    selector: "#endMeasureInput",
    prompt: "Try typing an end measure (example: 2).",
    doneText: "Done âœ… End measure set."
  }
},

{
  title: "Start practice",
  text: "Click Start Practice. The app will first play the selected measures, then wait for your input.",
  selector: "#startPracticeButton",
  dim: false,
  video: null,
  action: {
    type: "click",
    selector: "#startPracticeButton",
    prompt: "Click Start Practice to begin.",
    doneText: "Practice started â–¶ï¸",
    hideCardAfterClick: true
  },
  resume: {
    title: "Well done ðŸŽ‰",
    text: "Nice work. Now let's look at the next feature. Click Next when you're ready."
  }
},

{
  title: "Understanding mistakes",
text: "As you play, messages will appear here telling you whether each note was played correctly. If something isn't right, you'll also see an explanation of why.\n\nIf you'd like to try this yourself, you can click Back, choose a short section, and start practice again. Otherwise, click Next to continue.",
  selector: "#feedback",
  dim: false,
  video: null
},
{
  title: "Stop",
  text: "Click Stop anytime to stop playback or training. It's useful if you want to pause, fix a setting, or take a break.",
  selector: "#stopButton",
  dim: false,
  video: null
},

{
  title: "Reset",
  text: "Reset puts everything back to the default state (hand, measures, speed, toggles). Use this if you want a clean start.",
  selector: "#resetButton",
  dim: false,
  video: null,
  action: {
    type: "click",
    selector: "#resetButton",
    prompt: "Optional: click Reset to return everything to default.",
    doneText: "Done âœ… Reset."
  }
},
{
  title: "Hide note names",
  text: "Use this to hide or show the note names on the keyboard. It's great when you want to test yourself without hints.",
  selector: "#toggleNamesButton",
  dim: false,
  video: null,
  action: {
    type: "click",
    selector: "#toggleNamesButton",
    prompt: "Optional: click it once to hide/show the note names.",
    doneText: "Done âœ… Toggled note names."
  }
},
  {
  title: "Beat",
  text: "Turn Beat on to hear a steady metronome pulse while you play.",
  selector: "#beatToggle",
  dim: false,
  video: null
},
{
  title: "Counting",
  text: "Counting speaks the count out loud to help you stay in time.",
  selector: "#countToggle",
  dim: false,
  video: null
},
{
  title: "1 & 2 &",
  text: "This adds the 'and' subdivisions, which is useful for faster rhythms and tighter timing.",
  selector: "#subdivisionToggle",
  dim: false,
  video: null
},
{
  title: "Language",
  text: "Switch the counting language here.",
  selector: "#languageToggle",
  dim: false,
  video: null
},

{
  title: "Skip repeats in sheet",
  text: "If your sheet music has a repeat section, you can toggle this on or off. When it's on, repeats are skipped. When it's off, repeats will play normally.",
  selector: "#skipRepeatsCheckbox",
  dim: false,
  video: null
},
  {
  title: "Loop section",
  text: "Turn this on to keep repeating your selected measures. After it reaches the end measure, it automatically jumps back to the start measure and continues until you press Stop.",
  selector: "#loopCheckbox",
  dim: false,
  video: null
},


  {
  title: "Play full song",
  text: "Use this to play the full song with visuals. It's helpful to listen first before practicing a section.",
  selector: "#playSongButton",
  dim: false,
  video: null,
  action: {
    type: "click",
    selector: "#playSongButton",
    prompt: "Optional: click Play Full Song to try it.",
    doneText: "Done âœ… Full song started."
  }
},

{
  title: "Speed",
text: "You can slow things down or speed them up anytime. Try tapping + or - once. If you want to feel the difference more clearly, click Back and play the full song, then try changing the speed while it plays. Click Next when you're ready.",
  selector: "#speedDisplay",
  dim: false,
  video: null,
  action: {
    type: "observeTextChange",
    selector: "#speedDisplay",
    prompt: "Try clicking + or - to change the speed.",
    doneText: "Done âœ… Speed changed."
  }
},

{
  title: "Instant note feedback",
  text: "On the right, you'll see what you played under 'You pressed'. Under 'Correct note', you'll see the note you're supposed to play.",
  selector: "#sideNoteFeedback",
  dim: false,
  video: null
},
  
{
  title: "Free Mode",
  text: "Free Mode lets you play freely. You can play using your MIDI keyboard, or even click notes with your mouse.",
  selector: "#freeModeButton",
  dim: false,
  video: null,
  action: {
    type: "click",
    selector: "#freeModeButton",
    prompt: "Optional: click Free Mode to try it.",
    doneText: "Done âœ… Free Mode toggled."
  }
},
{
  title: "Demo complete ðŸŽ‰",
  text: "You've reached the end of the demo.\n\nThis was a trial version of the song, designed to show you how practice, feedback, and playback work.\n\nTo unlock the full song, please log in first.",
  selector: null,
  dim: true,
  video: null,
  nextLabel: "Login first",
  nextUrl: "https://riashandilya-svg.github.io/classicbollywoodmelodies/login.html"
}
];



  const frame = document.getElementById("appFrame");
  const overlay = document.getElementById("demoOverlay");
  const hi = document.getElementById("demoHighlight");
  const card = document.getElementById("demoCard");
  const titleEl = document.getElementById("demoTitle");
  const textEl = document.getElementById("demoText");
  const stepEl = document.getElementById("demoStep");
  const statusEl = document.getElementById("demoActionStatus");


  const videoWrap = document.getElementById("demoVideo");
  const videoEl = document.getElementById("demoVideoEl");

  const startBtn = document.getElementById("startTourBtn");
  const stopBtn = document.getElementById("stopTourBtn");
  const nextBtn = document.getElementById("nextBtn");
  const backBtn = document.getElementById("backBtn");
  const skipBtn = document.getElementById("skipBtn");

let idx = 0;
let running = false;
let currentHighlightedElement = null;

// for "wait until user clicks"
let waitCleanup = null;
let waitSatisfied = false;
let actionCleanup = null;
let actionDone = false;


  frame.src = APP_URL;

  function showTour(){
    running = true;
setOverlayDim(true);

    card.style.display = "block";
    stopBtn.style.display = "inline-block";
    startBtn.style.display = "none";
    goTo(0);
  }

  function hideTour(){
  running = false;

  overlay.style.display = "none";
  hi.style.display = "none";
  card.style.display = "none";

  stopBtn.style.display = "none";
  startBtn.style.display = "inline-block";

  stopVideo();

  // cleanup wait listener
  if (waitCleanup) {
    waitCleanup();
    waitCleanup = null;
  }
  waitSatisfied = false;

  // cleanup action listener
  if (actionCleanup) {
    actionCleanup();
    actionCleanup = null;
  }
  actionDone = false;
  setStatus("");

  setNextEnabled(true);
  currentHighlightedElement = null;
}

  function stopVideo(){
    videoEl.pause();
    videoEl.removeAttribute("src");
    videoEl.load();
    videoWrap.style.display = "none";
  }

  function playVideo(src){
    if (!src){
      stopVideo();
      return;
    }
    videoEl.src = src;
    videoWrap.style.display = "block";
    videoEl.currentTime = 0;
    videoEl.play().catch(()=>{});
  }

  function placeCardNear(rect){
    let top = 24;
    let left = 24;

    if (rect){
      const cardHeight = card.offsetHeight || 300; // estimate if not yet rendered
      const spaceBelow = window.innerHeight - rect.bottom;
      const spaceAbove = rect.top;
      
      // For dropdown elements (like #handSelect), prefer placing above to avoid overlap
      const isDropdown = currentHighlightedElement?.tagName === 'SELECT';
      
      if (isDropdown && spaceAbove > cardHeight + 60) {
        // Place above dropdown with extra spacing
        top = Math.max(14, rect.top - cardHeight - 40);
      } else if (spaceBelow > cardHeight + 40) {
        // Place below with spacing
        top = rect.bottom + 14;
      } else if (spaceAbove > cardHeight + 40) {
        // Place above with spacing
        top = Math.max(14, rect.top - cardHeight - 14);
      } else {
        // Not enough space either way, place to the side
        top = Math.max(14, Math.min(rect.top, window.innerHeight - cardHeight - 14));
      }
      
      left = Math.min(Math.max(14, rect.left), window.innerWidth - card.offsetWidth - 14);
    } else {
      top = 28;
      left = window.innerWidth - card.offsetWidth - 28;
    }

    card.style.top = top + "px";
    card.style.left = left + "px";
  }

  function updateHighlightPosition(){
    if (!currentHighlightedElement || !running) return;

    const doc = frame.contentWindow?.document;
    if (!doc) return;

    const r = currentHighlightedElement.getBoundingClientRect();
    const frameRect = frame.getBoundingClientRect();

    const rect = {
      left: frameRect.left + r.left,
      top: frameRect.top + r.top,
      right: frameRect.left + r.right,
      bottom: frameRect.top + r.bottom,
      width: r.width,
      height: r.height
    };

    const pad = 8;
    hi.style.left = (rect.left - pad) + "px";
    hi.style.top = (rect.top - pad) + "px";
    hi.style.width = (rect.width + pad*2) + "px";
    hi.style.height = (rect.height + pad*2) + "px";

    // Also update card position when highlight moves
    placeCardNear(rect);

    return rect;
  }

  function highlight(selector){
    const doc = frame.contentWindow?.document;
    if (!doc || !selector) {
      currentHighlightedElement = null;
      return null;
    }

    const el = doc.querySelector(selector);
    if (!el) {
      currentHighlightedElement = null;
      return null;
    }

    currentHighlightedElement = el;
    const r = el.getBoundingClientRect();
    const frameRect = frame.getBoundingClientRect();

    const rect = {
      left: frameRect.left + r.left,
      top: frameRect.top + r.top,
      right: frameRect.left + r.right,
      bottom: frameRect.top + r.bottom,
      width: r.width,
      height: r.height
    };

    const pad = 8;
    hi.style.display = "block";
    hi.style.left = (rect.left - pad) + "px";
    hi.style.top = (rect.top - pad) + "px";
    hi.style.width = (rect.width + pad*2) + "px";
    hi.style.height = (rect.height + pad*2) + "px";

    return rect;
  }
function setNextEnabled(enabled){
  nextBtn.disabled = !enabled;
  nextBtn.style.opacity = enabled ? "1" : "0.55";
  nextBtn.style.cursor = enabled ? "pointer" : "not-allowed";
}

function setupWaitForClick(selector){
  // clean up any previous waiting listener
  if (waitCleanup) {
    waitCleanup();
    waitCleanup = null;
  }
  waitSatisfied = false;

  // If no selector, nothing to wait for
  if (!selector) {
    setNextEnabled(true);
    return;
  }

  const doc = frame.contentWindow?.document;
  if (!doc) {
    setNextEnabled(true);
    return;
  }

  const el = doc.querySelector(selector);
  if (!el) {
    // If element not found, don't block the demo
    setNextEnabled(true);
    return;
  }

  // Disable Next until they click the target
  setNextEnabled(false);

  const onClick = (e) => {
    waitSatisfied = true;
    setNextEnabled(true);

    // remove listener after first click
    el.removeEventListener("click", onClick, true);
    waitCleanup = null;
  };

  // Use capture so we catch it even if the app stops propagation
  el.addEventListener("click", onClick, true);

  // cleanup function for when user goes back/next/exit
  waitCleanup = () => {
    el.removeEventListener("click", onClick, true);
  };
}
function setOverlayDim(dim){
  overlay.style.display = "block";
  overlay.style.background = dim ? "var(--demo-bg)" : "transparent";
}
function setStatus(msg, done=false){
  const el = document.getElementById("demoActionStatus");
  if (!el) return;

  el.textContent = msg || "";
  el.style.color = done ? "#1B5E20" : "#111";
  el.style.opacity = msg ? "1" : "0";
}

function setupActionWatcher(action){
  // clear previous watcher
  if (actionCleanup) {
    actionCleanup();
    actionCleanup = null;
  }
  actionDone = false;

  if (!action) {
    setStatus("");
    return;
  }

  const doc = frame.contentWindow?.document;
  if (!doc) {
    setStatus("");
    return;
  }

  const el = doc.querySelector(action.selector);
  if (!el) {
    setStatus("");
    return;
  }

  // show prompt text
  setStatus(action.prompt || "Try this nowâ€¦", false);

  const markDone = () => {
    if (actionDone) return;
    actionDone = true;
    setStatus(action.doneText || "Done âœ…", true);
  };

  if (action.type === "change") {
    el.addEventListener("change", markDone, true);
    actionCleanup = () => el.removeEventListener("change", markDone, true);
    return;
  }

if (action.type === "click") {
  const onClick = () => {
    markDone();

    // If this action wants the card to hide, hide it after click
    if (action.hideCardAfterClick) {
      card.style.display = "none";
    }
  };

  el.addEventListener("click", onClick, true);
  actionCleanup = () => el.removeEventListener("click", onClick, true);
  return;
}


  if (action.type === "input") {
    // done when they type something non-empty
    const onInput = () => {
      const v = (el.value ?? "").toString().trim();
      if (v.length) markDone();
    };
    el.addEventListener("input", onInput, true);
    actionCleanup = () => el.removeEventListener("input", onInput, true);
    return;
  }
  if (action.type === "observeTextChange") {
  const initial = (el.textContent || "").trim();

  const checkDone = () => {
    const now = (el.textContent || "").trim();
    return now && now !== initial;
  }

  if (checkDone()) {
    markDone();
    return;
  }

  const obs = new MutationObserver(() => {
    if (checkDone()) {
      markDone();
      obs.disconnect();
      actionCleanup = null;
    }
  });

  obs.observe(el, { childList: true, subtree: true, characterData: true });

  actionCleanup = () => obs.disconnect();
  return;
}

  if (action.type === "observe") {
    const checkDone = () => {
      if (action.classIncludes) {
        if (!el.classList.contains(action.classIncludes)) return false;
      }
      if (action.textIncludes) {
        const t = (el.textContent || "").trim();
        if (!t.includes(action.textIncludes)) return false;
      }
      return true;
    };

    // if it's already in the done state, mark done immediately
    if (checkDone()) {
      markDone();
      return;
    }

    const obs = new MutationObserver(() => {
      if (checkDone()) {
        markDone();
        obs.disconnect();
        actionCleanup = null;
      }
    });

    obs.observe(el, {
      attributes: true,
      attributeFilter: ["class"],
      childList: true,
      subtree: true,
      characterData: true
    });

    actionCleanup = () => obs.disconnect();
    return;
  }

  // unknown action type
  setStatus("");
}

  function render(){
    const step = STEPS[idx];
setOverlayDim(step.dim !== false);

    titleEl.textContent = step.title;
    textEl.textContent = step.text;
    stepEl.textContent = `${idx + 1} / ${STEPS.length}`;

    backBtn.disabled = idx === 0;
nextBtn.textContent =
  (idx === STEPS.length - 1)
    ? (STEPS[idx].nextLabel || "Done")
    : "Next";


    stopVideo();
    const rect = highlight(step.selector);
    placeCardNear(rect);
    setupActionWatcher(step.action);
    playVideo(step.video);
    // if this step requires clicking the feature, wait for it
if (step.waitForClick) {
  setupWaitForClick(step.selector);
} else {
  // normal steps: Next is available
  if (waitCleanup) {
    waitCleanup();
    waitCleanup = null;
  }
  waitSatisfied = false;
  setNextEnabled(true);
}

  }

  function goTo(newIndex){
    idx = Math.max(0, Math.min(STEPS.length - 1, newIndex));
    render();
  }

  startBtn.addEventListener("click", showTour);
  stopBtn.addEventListener("click", hideTour);


nextBtn.addEventListener("click", () => {
  const step = STEPS[idx];

  // If this step defines a link (like login), go there
  if (step && step.nextUrl && idx === STEPS.length - 1) {
    window.location.href = step.nextUrl;
    return;
  }

  if (idx === STEPS.length - 1) hideTour();
  else goTo(idx + 1);
});


  backBtn.addEventListener("click", () => goTo(idx - 1));
  skipBtn.addEventListener("click", hideTour);

  window.addEventListener("resize", () => {
    if (running) render();
  });
  
  // Update highlight position on iframe scroll or any scroll within iframe
  frame.addEventListener("load", () => {
    const iframeWin = frame.contentWindow;
    const iframeDoc = iframeWin?.document;
    
    if (iframeDoc) {
      // Listen for scroll on the document and all scrollable elements
      iframeDoc.addEventListener("scroll", () => {
        if (running && currentHighlightedElement) {
          updateHighlightPosition();
        }
      }, true); // Use capture to catch scroll on any element
      
      // Also use requestAnimationFrame to continuously update position
      let rafId;
      const updateLoop = () => {
        if (running && currentHighlightedElement) {
          updateHighlightPosition();
        }
        rafId = requestAnimationFrame(updateLoop);
      };
      
      // Start the update loop when tour is running
      const originalShowTour = showTour;
      showTour = function() {
        originalShowTour();
        rafId = requestAnimationFrame(updateLoop);
      };
      
      const originalHideTour = hideTour;
      hideTour = function() {
        originalHideTour();
        if (rafId) cancelAnimationFrame(rafId);
      };
    }
  });

  // Also update on main window scroll
  window.addEventListener("scroll", () => {
    if (running && currentHighlightedElement) {
      updateHighlightPosition();
    }
  }, true);

  // Continuous position update using animation frame
  function startPositionTracking() {
    if (!running || !currentHighlightedElement) return;
    
    updateHighlightPosition();
    requestAnimationFrame(startPositionTracking);
  }

  window.addEventListener("load", () => {
  showTour();
});
window.addEventListener("message", (event) => {
  // Only accept messages from the iframe page
  if (event.source !== frame.contentWindow) return;

  const data = event.data || {};
if (data.type === "tour:resume") {
  const step = STEPS[idx];

  // show the card again
  card.style.display = "block";

  // If this step has a custom resume message, show it
  if (step && step.resume) {
    titleEl.textContent = step.resume.title || step.title || "";
    titleEl.textContent  = step.resume.text  || step.text  || "";
    setStatus("", false); // clear the action status line

    // keep highlight positioned
    const rect = highlight(step.selector);
    placeCardNear(rect);

    // keep step counter + buttons correct
    stepEl.textContent = `${idx + 1} / ${STEPS.length}`;
    backBtn.disabled = idx === 0;
    nextBtn.textContent = (idx === STEPS.length - 1) ? "Done" : "Next";

    return; // don't call full render()
  }

  // fallback
  render();
}

});

</script>

</body>
</html>

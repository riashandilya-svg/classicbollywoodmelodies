<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Demo</title>

  <style>
    :root{
      --demo-bg: rgba(10,10,20,0.55);
      --demo-card: rgba(255,255,255,0.92);
      --demo-border: rgba(140,120,160,0.30);
      --demo-accent: #7E57C2;
      --demo-text: #111;
    }

    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#fff;
    }

    /* The real app */
    #appFrame{
      width: 100vw;
      height: 100vh;
      border: 0;
      display:block;
    }

    /* Overlay */
    #demoOverlay{
      position: fixed;
      inset: 0;
      background: var(--demo-bg);
      display:none;
      z-index: 999999;
      pointer-events: none;
    }

    /* Highlight rectangle */
    #demoHighlight{
      position: absolute;
      border: 3px solid var(--demo-accent);
      border-radius: 14px;
      box-shadow: 0 0 0 6px rgba(126,87,194,0.18), 0 18px 50px rgba(0,0,0,0.35);
      pointer-events: none;
      display:none;
      z-index: 1000000;
    }

    /* Tooltip card */
#demoCard{
  position: fixed;
  width: min(720px, calc(100vw - 40px)); /* wider, landscape */
  background: var(--demo-card);
  border: 1px solid var(--demo-border);
  border-radius: 18px;
  padding: 18px;
  color: var(--demo-text);
  box-shadow: 0 18px 60px rgba(0,0,0,0.35);
  z-index: 1000001;
  display:none;
}


    #demoTitle{
      font-weight: 800;
      font-size: 16px;
      margin: 0 0 6px 0;
    }

    #demoText{
      margin: 0 0 10px 0;
      line-height: 1.35;
      font-size: 14px;
    }

#demoVideo{
  width: 100%;
  max-height: 260px;
  max-width: 520px;            /* ‚úÖ add */
  border-radius: 12px;
  background: #000;
  display:none;
  margin: 10px auto 12px auto; /* ‚úÖ change */
  overflow:hidden;
  border: 1px solid rgba(0,0,0,0.10);
}


#demoVideo video{
  width: 100%;
  height: auto;                /* preserve natural aspect ratio */
  max-height: 260px;
  object-fit: contain;         /* no cropping */
  display:block;
  background:#000;
}
    

    #demoControls{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content: space-between;
      margin-top: 8px;
    }

    .btn{
      border: 0;
      background: var(--demo-accent);
      color: #fff;
      border-radius: 10px;
      padding: 10px 12px;
      font-weight: 700;
      cursor: pointer;
      font-size: 14px;
    }

    .btn.secondary{
      background: #111;
    }

    .btn.ghost{
      background: transparent;
      color: #111;
      border: 1px solid rgba(0,0,0,0.18);
    }
.btn.youtube{
  background: #ff0000;
}

    #demoStep{
      font-size: 13px;
      opacity: 0.8;
      font-weight: 600;
    }

    /* Small top bar for starting the tour */
    #demoTopBar{
      position: fixed;
      top: 14px;
      right: 14px;
      z-index: 1000002;
      display:flex;
      gap:10px;
      align-items:center;
    }
/* nicer spacing for text + bullets */
#demoText{
  margin: 0 0 10px 0;
  line-height: 1.45;
  font-size: 14px;
}

#demoText ul{
  margin: 10px 0 0 18px;
  padding: 0;
}

#demoText li{
  margin: 8px 0; /* space between bullets */
}


  </style>
</head>

<body>
  <!-- Your real app loads here -->
  <iframe id="appFrame" title="App"></iframe>

  <!-- Quick start button always visible -->
<div id="demoTopBar">
  <!-- NEW: YouTube button (left of Start Demo) -->
<a class="btn youtube" id="youtubeBtn"
   href="https://www.youtube.com/watch?v=YOUR_VIDEO_ID"
   target="_blank" rel="noopener">
  Demo Video
</a>


  <button class="btn" id="startTourBtn">Start Demo</button>

  <button class="btn ghost" id="loginBtn" type="button">Login</button>

  <button class="btn ghost" id="stopTourBtn" style="display:none;">Exit</button>
</div>



  <!-- Overlay + highlight + card -->
  <div id="demoOverlay"></div>
  <div id="demoHighlight"></div>

  <div id="demoCard">
    <h3 id="demoTitle"></h3>
<div id="demoText"></div>
    <div id="demoActionStatus" style="margin: 6px 0 10px 0; font-size: 13px; font-weight: 700;"></div>

<div id="demoImage">
  <img id="demoImageEl" alt="" />
</div>

    <div id="demoVideo">
      <video id="demoVideoEl" controls playsinline></video>
    </div>

    <div id="demoControls">
      <button class="btn ghost" id="backBtn">Back</button>
      <div id="demoStep"></div>
      <div style="display:flex; gap:10px;">
        <button class="btn secondary" id="skipBtn">Skip</button>
        <button class="btn" id="nextBtn">Next</button>
      </div>
    </div>
  </div>

<script>
  // STEP 1: SET YOUR REAL APP PAGE HERE
  const APP_URL = "https://riashandilya-svg.github.io/classicbollywoodmelodies/demo-app.html";

  // STEP 2: Define demo steps using CSS selectors that exist on the app page.
  // If a selector isn't found, the step will still show, but without highlight.
const STEPS = [
  
{
  title: "Connect your keyboard (USB)- Optional but Highly recommended",
  html: `
    <p style="margin:0 0 10px 0;">
      You may use your device's touch screen/mouse to learn, but for the best experience, connect a piano/MIDI keyboard to your device using a USB cable
      (usually USB-B on the keyboard side).
    </p>

    <p style="margin:0 0 10px 0;">
      If you see the MIDI permission popup, select <b>‚ÄúContinue allowing‚Ä¶‚Äù</b> and click <b>Done</b>.
    </p>

    <p style="margin:0 0 6px 0;"><b>If it doesn‚Äôt show up:</b></p>
    <ul>
      <li>Click the lock icon (or site controls) near the address bar</li>
      <li>Open <b>Site settings</b> / <b>Permissions</b></li>
      <li>Find <b>MIDI devices</b> and set it to <b>Allow</b></li>
      <li>Refresh the page and try again</li>
    </ul>
  `,
  selector: null,
  video: "midi-permission.mp4",
  hideBack: true
},


{
  title: "Choose which hand to practice",
  text: "Use this dropdown to pick Right Hand, Left Hand, or Both. Try changing it once, then click Next when you're ready.",
  selector: "#handSelect",
  dim: false,
  video: null,
  action: {
    type: "change",
    selector: "#handSelect",
    prompt: "Try switching the hand option once.",
    doneText: "Done ‚úÖ Hand selected."
  }
},
{
  title: "Pick your start measure",
  text: "Type the start measure from your sheet music here (for example: 1). Then click Next when you're ready.",
  selector: "#startMeasureInput",
  dim: false,
  video: null,
  action: {
    type: "input",
    selector: "#startMeasureInput",
    prompt: "Try typing a start measure (example: 1).",
    doneText: "Done ‚úÖ Start measure set."
  }
},
{
  title: "Pick your end measure",
  text: "Now type the end measure from your sheet music (for example: 2). Then click Next when you're ready.",
  selector: "#endMeasureInput",
  dim: false,
  video: null,
  action: {
    type: "input",
    selector: "#endMeasureInput",
    prompt: "Try typing an end measure (example: 2).",
    doneText: "Done ‚úÖ End measure set."
  }
},

{
  title: "Start practice",
  text: "Click Start Practice. The app will first play the selected measures, then wait for your input.",
  selector: "#startPracticeButton",
  dim: false,
  video: null,

  waitForClick: true,   // ‚úÖ disables Next until they click the button

  action: {
    type: "click",
    selector: "#startPracticeButton",
    prompt: "Click Start Practice to begin.",
    doneText: "Practice started ‚ñ∂Ô∏è",
    hideCardAfterClick: true
  },
  resume: {
    title: "Well done üéâ",
    text: "Nice work. Now let's look at the next feature. Click Next when you're ready."
  }
},


{
  title: "Understanding mistakes",
text: "As you play, messages will appear here telling you whether each note was played correctly. If something isn't right, you'll also see an explanation of why.\n\nIf you'd like to try this yourself, you can click Back, choose a short section, and start practice again. Otherwise, click Next to continue.",
  selector: "#feedback",
  dim: false,
  video: null
},
{
  title: "Stop",
  text: "Click Stop anytime to stop playback or training. It's useful if you want to pause, fix a setting, or take a break.",
  selector: "#stopButton",
  dim: false,
  video: null
},

{
  title: "Reset",
  text: "Reset puts everything back to the default state (hand, measures, speed, toggles). Use this if you want a clean start.",
  selector: "#resetButton",
  dim: false,
  video: null,
  action: {
    type: "click",
    selector: "#resetButton",
    prompt: "Optional: click Reset to return everything to default.",
    doneText: "Done ‚úÖ Reset."
  }
},
{
  title: "Hide note names",
  text: "Use this to hide or show the note names on the keyboard. It's great when you want to test yourself without hints.",
  selector: "#toggleNamesButton",
  dim: false,
  video: null,
  action: {
    type: "click",
    selector: "#toggleNamesButton",
    prompt: "Optional: click it once to hide/show the note names.",
    doneText: "Done ‚úÖ Toggled note names."
  }
},
  {
  title: "Beat",
  text: "Turn Beat on to hear a steady metronome pulse while you play.",
  selector: "#beatToggle",
  dim: false,
  video: null
},
{
  title: "Counting",
  text: "Counting speaks the count out loud to help you stay in time.",
  selector: "#countToggle",
  dim: false,
  video: null
},
{
  title: "1 & 2 &",
  text: "This adds the 'and' subdivisions, which is useful for faster rhythms and tighter timing.",
  selector: "#subdivisionToggle",
  dim: false,
  video: null
},
{
  title: "Language",
  text: "Switch the counting language here.",
  selector: "#languageToggle",
  dim: false,
  video: null
},

{
  title: "Skip repeats in sheet",
  text: "If your sheet music has a repeat section, you can toggle this on or off. When it's on, repeats are skipped. When it's off, repeats will play normally.",
  selector: "#skipRepeatsCheckbox",
  dim: false,
  video: null
},
  {
  title: "Loop section",
  text: "Turn this on to keep repeating your selected measures. After it reaches the end measure, it automatically jumps back to the start measure and continues until you press Stop.",
  selector: "#loopCheckbox",
  dim: false,
  video: null
},
  {
  title: "Play full song",
  text: "Use this to play the full song with visuals. It's helpful to listen first before practicing a section.",
  selector: "#playSongButton",
  dim: false,
  video: null,
  action: {
    type: "click",
    selector: "#playSongButton",
    prompt: "Optional: click Play Full Song to try it.",
    doneText: "Done ‚úÖ Full song started."
  }
},

{
  title: "Speed",
text: "You can slow things down or speed them up anytime. Try tapping + or - once. If you want to feel the difference more clearly, click Back and play the full song, then try changing the speed while it plays. Click Next when you're ready.",
  selector: "#speedDisplay",
  dim: false,
  video: null,
  action: {
    type: "observeTextChange",
    selector: "#speedDisplay",
    prompt: "Try clicking + or - to change the speed.",
    doneText: "Done ‚úÖ Speed changed."
  }
},

{
  title: "Instant note feedback",
  text: "On the right, you'll see what you played under 'You pressed'. Under 'Correct note', you'll see the note you're supposed to play.",
  selector: "#sideNoteFeedback",
  dim: false,
  video: null
},
  
{
  title: "Free Mode",
  text: "Free Mode lets you play freely. You can play using your MIDI keyboard, or even click notes with your mouse.",
  selector: "#freeModeButton",
  dim: false,
  video: null,
  action: {
    type: "click",
    selector: "#freeModeButton",
    prompt: "Optional: click Free Mode to try it.",
    doneText: "Done ‚úÖ Free Mode toggled."
  }
},
{
  title: "Demo complete üéâ",
  text: "You've reached the end of the demo.\n\nThis was a trial version of the song, designed to show you how practice, feedback, and playback work.\n\nTo unlock the full song, please log in first.",
  selector: null,
  dim: true,
  video: null,
  nextLabel: "Login first",
  nextUrl: "https://riashandilya-svg.github.io/classicbollywoodmelodies/login.html"
}
];



  const frame = document.getElementById("appFrame");
  const overlay = document.getElementById("demoOverlay");
  const hi = document.getElementById("demoHighlight");
  const card = document.getElementById("demoCard");
  const titleEl = document.getElementById("demoTitle");
  const textEl = document.getElementById("demoText");
  const stepEl = document.getElementById("demoStep");
  const statusEl = document.getElementById("demoActionStatus");


  const videoWrap = document.getElementById("demoVideo");
  const videoEl = document.getElementById("demoVideoEl");
const imageWrap = document.getElementById("demoImage");
const imageEl = document.getElementById("demoImageEl");

function stopImage(){
  imageEl.removeAttribute("src");
  imageEl.alt = "";
  imageWrap.style.display = "none";
}

function showImage(src, altText){
  if (!src){
    stopImage();
    return;
  }
  imageEl.src = src;
  imageEl.alt = altText || "";
  imageWrap.style.display = "block";
}

  const startBtn = document.getElementById("startTourBtn");
  const stopBtn = document.getElementById("stopTourBtn");
  const nextBtn = document.getElementById("nextBtn");
  const backBtn = document.getElementById("backBtn");
  const skipBtn = document.getElementById("skipBtn");
  const loginBtn = document.getElementById("loginBtn");
loginBtn.addEventListener("click", () => {
  window.location.href = "https://riashandilya-svg.github.io/classicbollywoodmelodies/login.html";
});


let idx = 0;
let running = false;
let currentHighlightedElement = null;

// for "wait until user clicks"
let waitCleanup = null;
let waitSatisfied = false;
let actionCleanup = null;
let actionDone = false;


  frame.src = APP_URL;

  function showTour(){
    running = true;
setOverlayDim(true);

    card.style.display = "block";
    stopBtn.style.display = "inline-block";
    startBtn.style.display = "none";
    goTo(0);
  }

  function hideTour(){
  running = false;

  overlay.style.display = "none";
  hi.style.display = "none";
  card.style.display = "none";

  stopBtn.style.display = "none";
  startBtn.style.display = "inline-block";

  stopVideo();

  // cleanup wait listener
  if (waitCleanup) {
    waitCleanup();
    waitCleanup = null;
  }
  waitSatisfied = false;

  // cleanup action listener
  if (actionCleanup) {
    actionCleanup();
    actionCleanup = null;
  }
  actionDone = false;
  setStatus("");

  setNextEnabled(true);
  currentHighlightedElement = null;
}

  function stopVideo(){
    videoEl.pause();
    videoEl.removeAttribute("src");
    videoEl.load();
    videoWrap.style.display = "none";
  }

  function playVideo(src){
    if (!src){
      stopVideo();
      return;
    }
    videoEl.src = src;
    videoWrap.style.display = "block";
    videoEl.currentTime = 0;
    videoEl.play().catch(()=>{});
  }

  function placeCardNear(rect){
    let top = 24;
    let left = 24;

    if (rect){
      const cardHeight = card.offsetHeight || 300; // estimate if not yet rendered
      const spaceBelow = window.innerHeight - rect.bottom;
      const spaceAbove = rect.top;
      
      // For dropdown elements (like #handSelect), prefer placing above to avoid overlap
      const isDropdown = currentHighlightedElement?.tagName === 'SELECT';
      
      if (isDropdown && spaceAbove > cardHeight + 60) {
        // Place above dropdown with extra spacing
        top = Math.max(14, rect.top - cardHeight - 40);
      } else if (spaceBelow > cardHeight + 40) {
        // Place below with spacing
        top = rect.bottom + 14;
      } else if (spaceAbove > cardHeight + 40) {
        // Place above with spacing
        top = Math.max(14, rect.top - cardHeight - 14);
      } else {
        // Not enough space either way, place to the side
        top = Math.max(14, Math.min(rect.top, window.innerHeight - cardHeight - 14));
      }
      
      left = Math.min(Math.max(14, rect.left), window.innerWidth - card.offsetWidth - 14);
} else {
  // No highlight target (selector: null) ‚Äî center the card, landscape style
  const topBar = document.getElementById("demoTopBar");
  const topBarH = topBar ? topBar.getBoundingClientRect().height : 0;

  const cardW = card.offsetWidth || 720;
  left = Math.max(14, (window.innerWidth - cardW) / 2);

  // place it visually centered, but not overlapping top bar
  top = Math.max(28 + topBarH + 16, (window.innerHeight * 0.18));
}



    card.style.top = top + "px";
    card.style.left = left + "px";
  }

  function updateHighlightPosition(){
    if (!currentHighlightedElement || !running) return;

    const doc = frame.contentWindow?.document;
    if (!doc) return;

    const r = currentHighlightedElement.getBoundingClientRect();
    const frameRect = frame.getBoundingClientRect();

    const rect = {
      left: frameRect.left + r.left,
      top: frameRect.top + r.top,
      right: frameRect.left + r.right,
      bottom: frameRect.top + r.bottom,
      width: r.width,
      height: r.height
    };

    const pad = 8;
    hi.style.left = (rect.left - pad) + "px";
    hi.style.top = (rect.top - pad) + "px";
    hi.style.width = (rect.width + pad*2) + "px";
    hi.style.height = (rect.height + pad*2) + "px";

    // Also update card position when highlight moves
    placeCardNear(rect);

    return rect;
  }

  function highlight(selector){
    const doc = frame.contentWindow?.document;
    if (!doc || !selector) {
      currentHighlightedElement = null;
      return null;
    }

    const el = doc.querySelector(selector);
    if (!el) {
      currentHighlightedElement = null;
      return null;
    }

    currentHighlightedElement = el;
    const r = el.getBoundingClientRect();
    const frameRect = frame.getBoundingClientRect();

    const rect = {
      left: frameRect.left + r.left,
      top: frameRect.top + r.top,
      right: frameRect.left + r.right,
      bottom: frameRect.top + r.bottom,
      width: r.width,
      height: r.height
    };

    const pad = 8;
    hi.style.display = "block";
    hi.style.left = (rect.left - pad) + "px";
    hi.style.top = (rect.top - pad) + "px";
    hi.style.width = (rect.width + pad*2) + "px";
    hi.style.height = (rect.height + pad*2) + "px";

    return rect;
  }
function setNextEnabled(enabled){
  nextBtn.disabled = !enabled;
  nextBtn.style.opacity = enabled ? "1" : "0.55";
  nextBtn.style.cursor = enabled ? "pointer" : "not-allowed";
}

function setupWaitForClick(selector){
  // clean up any previous waiting listener
  if (waitCleanup) {
    waitCleanup();
    waitCleanup = null;
  }
  waitSatisfied = false;

  // If no selector, nothing to wait for
  if (!selector) {
    setNextEnabled(true);
    return;
  }

  const doc = frame.contentWindow?.document;
  if (!doc) {
    setNextEnabled(true);
    return;
  }

  const el = doc.querySelector(selector);
  if (!el) {
    // If element not found, don't block the demo
    setNextEnabled(true);
    return;
  }

  // Disable Next until they click the target
  setNextEnabled(false);

  const onClick = (e) => {
    waitSatisfied = true;
    setNextEnabled(true);

    // remove listener after first click
    el.removeEventListener("click", onClick, true);
    waitCleanup = null;
  };

  // Use capture so we catch it even if the app stops propagation
  el.addEventListener("click", onClick, true);

  // cleanup function for when user goes back/next/exit
  waitCleanup = () => {
    el.removeEventListener("click", onClick, true);
  };
}
function setOverlayDim(dim){
  overlay.style.display = "block";
  overlay.style.background = dim ? "var(--demo-bg)" : "transparent";
}
function setStatus(msg, done=false){
  const el = document.getElementById("demoActionStatus");
  if (!el) return;

  el.textContent = msg || "";
  el.style.color = done ? "#1B5E20" : "#111";
  el.style.opacity = msg ? "1" : "0";
}

function setupActionWatcher(action){
  // clear previous watcher
  if (actionCleanup) {
    actionCleanup();
    actionCleanup = null;
  }
  actionDone = false;

  if (!action) {
    setStatus("");
    return;
  }

  const doc = frame.contentWindow?.document;
  if (!doc) {
    setStatus("");
    return;
  }

  const el = doc.querySelector(action.selector);
  if (!el) {
    setStatus("");
    return;
  }

  // show prompt text
  setStatus(action.prompt || "Try this now‚Ä¶", false);

  const markDone = () => {
    if (actionDone) return;
    actionDone = true;
    setStatus(action.doneText || "Done ‚úÖ", true);
  };

  if (action.type === "change") {
    el.addEventListener("change", markDone, true);
    actionCleanup = () => el.removeEventListener("change", markDone, true);
    return;
  }

if (action.type === "click") {
  const onClick = () => {
    markDone();

    // If this action wants the card to hide, hide it after click
    if (action.hideCardAfterClick) {
      card.style.display = "none";
    }
  };

  el.addEventListener("click", onClick, true);
  actionCleanup = () => el.removeEventListener("click", onClick, true);
  return;
}


  if (action.type === "input") {
    // done when they type something non-empty
    const onInput = () => {
      const v = (el.value ?? "").toString().trim();
      if (v.length) markDone();
    };
    el.addEventListener("input", onInput, true);
    actionCleanup = () => el.removeEventListener("input", onInput, true);
    return;
  }
  if (action.type === "observeTextChange") {
  const initial = (el.textContent || "").trim();

  const checkDone = () => {
    const now = (el.textContent || "").trim();
    return now && now !== initial;
  }

  if (checkDone()) {
    markDone();
    return;
  }

  const obs = new MutationObserver(() => {
    if (checkDone()) {
      markDone();
      obs.disconnect();
      actionCleanup = null;
    }
  });

  obs.observe(el, { childList: true, subtree: true, characterData: true });

  actionCleanup = () => obs.disconnect();
  return;
}

  if (action.type === "observe") {
    const checkDone = () => {
      if (action.classIncludes) {
        if (!el.classList.contains(action.classIncludes)) return false;
      }
      if (action.textIncludes) {
        const t = (el.textContent || "").trim();
        if (!t.includes(action.textIncludes)) return false;
      }
      return true;
    };

    // if it's already in the done state, mark done immediately
    if (checkDone()) {
      markDone();
      return;
    }

    const obs = new MutationObserver(() => {
      if (checkDone()) {
        markDone();
        obs.disconnect();
        actionCleanup = null;
      }
    });

    obs.observe(el, {
      attributes: true,
      attributeFilter: ["class"],
      childList: true,
      subtree: true,
      characterData: true
    });

    actionCleanup = () => obs.disconnect();
    return;
  }

  // unknown action type
  setStatus("");
}

  function render(){
    const step = STEPS[idx];
setOverlayDim(step.dim !== false);

    titleEl.textContent = step.title;
// allow HTML for steps that provide it (bullets, links, etc.)
if (step.html) textEl.innerHTML = step.html;
else textEl.textContent = step.text || "";
    stepEl.textContent = `${idx + 1} / ${STEPS.length}`;

    backBtn.disabled = idx === 0;
    // Hide Back button only for steps that request it
backBtn.style.display = (STEPS[idx].hideBack) ? "none" : "inline-block";

nextBtn.textContent =
  (idx === STEPS.length - 1)
    ? (STEPS[idx].nextLabel || "Done")
    : "Next";

stopVideo();
stopImage();

const rect = highlight(step.selector);
placeCardNear(rect);

setupActionWatcher(step.action);
playVideo(step.video);
showImage(step.image, step.imageAlt);

    // if this step requires clicking the feature, wait for it
if (step.waitForClick) {
  setupWaitForClick(step.selector);
} else {
  // normal steps: Next is available
  if (waitCleanup) {
    waitCleanup();
    waitCleanup = null;
  }
  waitSatisfied = false;
  setNextEnabled(true);
}

  }

  function goTo(newIndex){
    idx = Math.max(0, Math.min(STEPS.length - 1, newIndex));
    render();
  }

  startBtn.addEventListener("click", showTour);
  stopBtn.addEventListener("click", hideTour);


nextBtn.addEventListener("click", () => {
  const step = STEPS[idx];

  // If this step defines a link (like login), go there
  if (step && step.nextUrl && idx === STEPS.length - 1) {
    window.location.href = step.nextUrl;
    return;
  }

  if (idx === STEPS.length - 1) hideTour();
  else goTo(idx + 1);
});


  backBtn.addEventListener("click", () => goTo(idx - 1));
skipBtn.addEventListener("click", () => {
  // Skip only the current step and move to the next one
  if (idx < STEPS.length - 1) {
    goTo(idx + 1);
  } else {
    hideTour();
  }
});


  window.addEventListener("resize", () => {
    if (running) render();
  });
  
  // Update highlight position on iframe scroll or any scroll within iframe
  frame.addEventListener("load", () => {
    const iframeWin = frame.contentWindow;
    const iframeDoc = iframeWin?.document;
    
    if (iframeDoc) {
      // Listen for scroll on the document and all scrollable elements
      iframeDoc.addEventListener("scroll", () => {
        if (running && currentHighlightedElement) {
          updateHighlightPosition();
        }
      }, true); // Use capture to catch scroll on any element
      
      // Also use requestAnimationFrame to continuously update position
      let rafId;
      const updateLoop = () => {
        if (running && currentHighlightedElement) {
          updateHighlightPosition();
        }
        rafId = requestAnimationFrame(updateLoop);
      };
      
      // Start the update loop when tour is running
      const originalShowTour = showTour;
      showTour = function() {
        originalShowTour();
        rafId = requestAnimationFrame(updateLoop);
      };
      
      const originalHideTour = hideTour;
      hideTour = function() {
        originalHideTour();
        if (rafId) cancelAnimationFrame(rafId);
      };
    }
  });

  // Also update on main window scroll
  window.addEventListener("scroll", () => {
    if (running && currentHighlightedElement) {
      updateHighlightPosition();
    }
  }, true);

  // Continuous position update using animation frame
  function startPositionTracking() {
    if (!running || !currentHighlightedElement) return;
    
    updateHighlightPosition();
    requestAnimationFrame(startPositionTracking);
  }

window.addEventListener("load", () => {
  // do not auto-start demo
});

window.addEventListener("message", (event) => {
  // Only accept messages from the iframe page
  if (event.source !== frame.contentWindow) return;

  const data = event.data || {};
if (data.type === "tour:resume") {
  const step = STEPS[idx];

  // show the card again
  card.style.display = "block";

  // If this step has a custom resume message, show it
  if (step && step.resume) {
    titleEl.textContent = step.resume.title || step.title || "";
if (step.resume && step.resume.html) textEl.innerHTML = step.resume.html;
else if (step.html) textEl.innerHTML = step.html;
else textEl.textContent = step.resume.text || step.text || "";
    setStatus("", false); // clear the action status line

    // keep highlight positioned
    const rect = highlight(step.selector);
    placeCardNear(rect);

    // keep step counter + buttons correct
    stepEl.textContent = `${idx + 1} / ${STEPS.length}`;
    backBtn.disabled = idx === 0;
    nextBtn.textContent = (idx === STEPS.length - 1) ? "Done" : "Next";

    return; // don't call full render()
  }

  // fallback
  render();
}

});

</script>

</body>
</html>
